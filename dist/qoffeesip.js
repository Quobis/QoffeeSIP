/*
@source: https://github.com/Quobis/QoffeeSIP
Copyright (C) Quobis
Licensed under GNU-LGPL-3.0-or-later (http://www.gnu.org/licenses/lgpl-3.0.html)
*/
// Generated by CoffeeScript 1.4.0
(function() {
  var API, Parser, RTC, SipStack, SipTransaction,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  RTC = (function(_super) {

    __extends(RTC, _super);

    RTC.include(Spine.Events);

    function RTC(args) {
      this.toggleMuteVideo = __bind(this.toggleMuteVideo, this);

      this.toggleMuteAudio = __bind(this.toggleMuteAudio, this);

      this.close = __bind(this.close, this);

      this.receiveAnswer = __bind(this.receiveAnswer, this);

      this.receiveOffer = __bind(this.receiveOffer, this);

      this.receive = __bind(this.receive, this);

      this.createAnswer = __bind(this.createAnswer, this);

      this.createOffer = __bind(this.createOffer, this);

      this.setLocalDescription = __bind(this.setLocalDescription, this);

      this.triggerSDP = __bind(this.triggerSDP, this);

      this.createStream = __bind(this.createStream, this);

      this.createPeerConnection = __bind(this.createPeerConnection, this);

      this.start = __bind(this.start, this);

      this.browserSupport = __bind(this.browserSupport, this);

      var key, value, _ref;
      console.log("[INFO] RTC constructor");
      for (key in args) {
        value = args[key];
        this[key] = value;
      }
      if (this.mediaElements != null) {
        this.$dom1 = this.mediaElements.localMedia;
        this.$dom2 = this.mediaElements.remoteMedia;
      } else {
        this.$dom1 = this.$dom2 = null;
      }
      if ((_ref = this.mediaConstraints) == null) {
        this.mediaConstraints = {
          audio: true,
          video: true
        };
      }
      this.browserSupport();
      this.iceServers = [];
      if (this.stunServer != null) {
        this.iceServers.push(this.stunServer);
      }
      if (this.turnServer != null) {
        this.iceServers.push(this.turnServer);
      }
    }

    RTC.prototype.browserSupport = function() {
      var _this = this;
      if (navigator.mozGetUserMedia) {
        this.browser = "firefox";
        this.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
        this.PeerConnection = mozRTCPeerConnection;
        this.RTCSessionDescription = mozRTCSessionDescription;
        this.attachStream = function($d, stream) {
          if (!$d) {
            return;
          }
          console.log("[INFO] attachStream");
          $d.attr('src', window.URL.createObjectURL(stream));
          return $d.get(0).play();
        };
        MediaStream.prototype.getVideoTracks = function() {
          return [];
        };
        MediaStream.prototype.getAudioTracks = function() {
          return [];
        };
      }
      if (navigator.webkitGetUserMedia) {
        this.browser = "chrome";
        this.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
        this.PeerConnection = webkitRTCPeerConnection;
        this.RTCSessionDescription = RTCSessionDescription;
        this.attachStream = function($d, stream) {
          var url;
          if (!($d != null)) {
            return;
          }
          console.log("[INFO] attachStream");
          url = webkitURL.createObjectURL(stream);
          return $d.attr('src', url);
        };
        if (!webkitMediaStream.prototype.getVideoTracks) {
          webkitMediaStream.prototype.getVideoTracks = function() {
            return this.videoTracks;
          };
        }
        if (!webkitMediaStream.prototype.getAudioTracks) {
          webkitMediaStream.prototype.getAudioTracks = function() {
            return this.audioTracks;
          };
        }
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
          webkitRTCPeerConnection.prototype.getLocalStreams = function() {
            return this.localStreams;
          };
          return webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
            return this.remoteStreams;
          };
        }
      }
    };

    RTC.prototype.start = function() {
      console.log("PeerConnection starting");
      this.noMoreCandidates = false || (this.browser === "firefox");
      return this.createPeerConnection();
    };

    RTC.prototype.createPeerConnection = function() {
      var _this = this;
      console.log("[INFO] createPeerConnection");
      console.log("[MEDIA] ICE servers");
      console.log(this.iceServers);
      this.pc = new this.PeerConnection({
        "iceServers": this.iceServers
      });
      this.pc.onaddstream = function(event) {
        console.log("[MEDIA] Stream added");
        _this.remotestream = event.stream;
        _this.attachStream(_this.$dom2, _this.remotestream);
        return _this.trigger("remotestream", _this.remotestream);
      };
      this.pc.onicecandidate = function(evt, moreToFollow) {
        var candidate;
        console.log("[INFO] onicecandidate");
        console.log(_this.pc.iceState);
        if (evt.candidate) {
          console.log("[INFO] New ICE candidate:");
          candidate = {
            type: 'candidate',
            label: evt.candidate.sdpMLineIndex,
            id: evt.candidate.sdpMid,
            candidate: evt.candidate.candidate
          };
          return console.log("" + candidate.candidate);
        } else {
          console.log("[INFO] No more ice candidates");
          _this.noMoreCandidates = true;
          if (_this.pc.localDescription != null) {
            return _this.triggerSDP();
          }
        }
      };
      if (this.browser === "chrome") {
        this.pc.onicechange = function(event) {
          return console.log("[INFO] icestate changed -> " + _this.pc.iceState);
        };
        this.pc.onstatechange = function(event) {
          return console.log("[INFO] peerconnectionstate changed -> " + _this.pc.readyState);
        };
        this.pc.onopen = function() {
          return console.log("[MEDIA] peerconnection opened");
        };
        this.pc.onclose = function() {
          return console.log("[INFO] peerconnection closed");
        };
      }
      return this.createStream();
    };

    RTC.prototype.createStream = function() {
      var gumFail, gumSuccess,
        _this = this;
      console.log("[INFO] createStream");
      if (this.localstream != null) {
        console.log("[INFO] Using media previously getted.");
        this.pc.addStream(this.localstream);
        return this.attachStream(this.$dom1, this.localstream);
      } else {
        gumSuccess = function(stream) {
          _this.localstream = stream;
          console.log("[INFO] getUserMedia successed");
          console.log(stream);
          _this.pc.addStream(_this.localstream);
          _this.attachStream(_this.$dom1, _this.localstream);
          _this.trigger("localstream", _this.localstream);
          return console.log("localstream", _this.localstream);
        };
        gumFail = function(error) {
          console.error(error);
          console.error("GetUserMedia error");
          return _this.trigger("error", "getUserMedia");
        };
        return this.getUserMedia(this.mediaConstraints, gumSuccess, gumFail);
      }
    };

    RTC.prototype.triggerSDP = function() {
      var sdp;
      console.log("[MEDIA]");
      sdp = this.pc.localDescription.sdp;
      return this.trigger("sdp", sdp);
    };

    RTC.prototype.setLocalDescription = function(sessionDescription, callback) {
      var fail, success,
        _this = this;
      success = function() {
        console.log("[INFO] setLocalDescription successed");
        if (_this.noMoreCandidates) {
          return _this.triggerSDP();
        }
      };
      fail = function() {
        return _this.trigger("error", "setLocalDescription", sessionDescription);
      };
      return this.pc.setLocalDescription(sessionDescription, success, fail);
    };

    RTC.prototype.createOffer = function() {
      var error,
        _this = this;
      console.log("[INFO] createOffer");
      error = function(e) {
        return _this.trigger("error", "createOffer", e);
      };
      return this.pc.createOffer(this.setLocalDescription, error, {});
    };

    RTC.prototype.createAnswer = function() {
      var error,
        _this = this;
      console.log("[INFO] createAnswer");
      error = function(e) {
        return _this.trigger("error", "createAnswer", e);
      };
      return this.pc.createAnswer(this.setLocalDescription, error, {});
    };

    RTC.prototype.receive = function(sdp, type, callback) {
      var description, success,
        _this = this;
      if (callback == null) {
        callback = function() {
          return null;
        };
      }
      success = function() {
        console.log("[INFO] Remote description setted.");
        console.log("[INFO] localDescription:");
        console.log(_this.pc.localDescription);
        console.log("[INFO] remotelocalDescription:");
        console.log(_this.pc.remoteDescription);
        return callback();
      };
      description = new this.RTCSessionDescription({
        type: type,
        sdp: sdp
      });
      return this.pc.setRemoteDescription(description, success, function() {
        return _this.trigger("error", "setRemoteDescription", description);
      });
    };

    RTC.prototype.receiveOffer = function(sdp, callback) {
      if (callback == null) {
        callback = null;
      }
      console.log("[INFO] Received offer");
      return this.receive(sdp, "offer", callback);
    };

    RTC.prototype.receiveAnswer = function(sdp) {
      console.log("[INFO] Received answer");
      return this.receive(sdp, "answer");
    };

    RTC.prototype.close = function() {
      try {
        return this.pc.close();
      } catch (e) {
        console.log("[ERROR] Error closing peerconnection");
        return console.log(e);
      } finally {
        this.pc = null;
        this.start();
      }
    };

    RTC.prototype.toggleMuteAudio = function() {
      var audioTrack, audioTracks, bool, _i, _len;
      audioTracks = this.localstream.getAudioTracks();
      console.log(audioTracks);
      if (audioTracks.length === 0) {
        console.log("[MEDIA] No local audio available.");
        return;
      }
      if (this.isAudioMuted) {
        bool = true;
        console.log("[MEDIA] Audio unmuted.");
      } else {
        bool = false;
        console.log("[MEDIA] Audio muted.");
      }
      for (_i = 0, _len = audioTracks.length; _i < _len; _i++) {
        audioTrack = audioTracks[_i];
        audioTrack.enabled = bool;
      }
      return this.isAudioMuted = !bool;
    };

    RTC.prototype.toggleMuteVideo = function() {
      var bool, videoTrack, videoTracks, _i, _len;
      videoTracks = this.localstream.getVideoTracks();
      console.log(videoTracks);
      if (videoTracks.length === 0) {
        console.log("[MEDIA] No local audio available.");
        return;
      }
      if (this.isVideoMuted) {
        bool = true;
        console.log("Video unmuted.");
      } else {
        bool = false;
        console.log("Video muted.");
      }
      for (_i = 0, _len = videoTracks.length; _i < _len; _i++) {
        videoTrack = videoTracks[_i];
        videoTrack.enabled = bool;
      }
      return this.isVideoMuted = !bool;
    };

    return RTC;

  })(Spine.Module);

  window.RTC = RTC;

  Parser = (function() {

    function Parser() {}

    Parser.getRegExprResult = function(pkt, re, indexes) {
      var index, key, line, result, _i, _len, _ref;
      result = {};
      _ref = _.keys(indexes);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        result[key] = void 0;
      }
      line = re.exec(pkt);
      if (line != null) {
        for (key in indexes) {
          index = indexes[key];
          if (index < line.length) {
            result[key] = line[index];
          }
        }
      }
      return result;
    };

    Parser.parse = function(pkt) {
      var message;
      console.log("[INFO] Parsing");
      console.log(pkt);
      message = {};
      _.extend(message, {
        frame: pkt
      });
      _.extend(message, this.parseFirstLine(pkt));
      _.extend(message, this.parseVias(pkt));
      _.extend(message, this.parseFrom(pkt));
      _.extend(message, this.parseTo(pkt));
      _.extend(message, this.parseRecordRoutes(pkt));
      _.extend(message, this.parseRoute(pkt));
      _.extend(message, this.parseContact(pkt));
      _.extend(message, this.parseCallId(pkt));
      _.extend(message, this.parseCSeq(pkt));
      _.extend(message, this.parseChallenge(pkt));
      _.extend(message, this.parseExpires(pkt));
      _.extend(message, this.parseContentType(pkt));
      _.extend(message, this.parseContent(pkt));
      console.log("[INFO] Parsed");
      console.log(message);
      return message;
    };

    Parser.parseFirstLine = function(pkt) {
      var code, firstLine, meth, methodRE, requestUri, responseRE, tmp;
      firstLine = pkt.split("\r\n")[0];
      responseRE = /^SIP\/2\.0 \d+/;
      if (responseRE.test(firstLine)) {
        tmp = firstLine.split(" ");
        tmp = _.rest(tmp);
        code = parseInt(tmp[0]);
        tmp = _.rest(tmp);
        meth = tmp.join(" ");
        return {
          responseCode: code,
          meth: meth,
          type: "response"
        };
      } else {
        methodRE = /(\w+)/;
        meth = methodRE.exec(firstLine)[0];
        requestUri = firstLine.split(" ")[1].split(";")[0];
        return {
          meth: meth,
          type: "request"
        };
      }
    };

    Parser.parseVias = function(pkt) {
      var branchRE, ret, tmp, viaRE, vias;
      viaRE = /Via\:\s+SIP\/2\.0\/[A-Z]+\s+([A-z0-9\.\:]+)/;
      tmp = _.filter(pkt.split("\r\n"), function(line) {
        return viaRE.test(line);
      });
      vias = _.map(tmp, function(via) {
        return via.replace(/;received=[A-z0-9\.\:]+/, "");
      });
      console.log(vias);
      if (vias.length > 0) {
        ret = this.getRegExprResult(vias[0], viaRE, {
          sentBy: 1
        });
        branchRE = /branch=([^;\s]+)/;
        ret = this.getRegExprResult(vias[0], branchRE, {
          branch: 1
        });
      }
      console.log(_.extend({
        vias: vias
      }, ret));
      return _.extend({
        vias: vias
      }, ret);
    };

    Parser.parseRecordRoutes = function(pkt) {
      var recordRouteRE, recordRoutes;
      recordRouteRE = /Record-Route\:/i;
      recordRoutes = _.filter(pkt.split("\r\n"), function(line) {
        return recordRouteRE.test(line);
      });
      return {
        recordRoutes: recordRoutes
      };
    };

    Parser.parseFrom = function(pkt) {
      var lineFromRE;
      lineFromRE = /From:(\s?".+"\s?)?\s*<?sips?:((.+)@[A-z0-9\.]+)>?(;tag=(.+))?/i;
      return this.getRegExprResult(pkt, lineFromRE, {
        from: 2,
        ext: 3,
        fromTag: 5
      });
    };

    Parser.parseTo = function(pkt) {
      var lineToRE;
      lineToRE = /To:(\s?".+"\s?)?\s*<?sips?:((.+)@[A-z0-9\.]+)>?(;tag=(.+))?/i;
      return this.getRegExprResult(pkt, lineToRE, {
        to: 2,
        ext2: 3,
        toTag: 5
      });
    };

    Parser.parseCallId = function(pkt) {
      var lineCallIdRE;
      lineCallIdRE = /Call-ID:\s(.+)/i;
      return this.getRegExprResult(pkt, lineCallIdRE, {
        callId: 1
      });
    };

    Parser.parseRoute = function(pkt) {
      var line, lineRoute, route, tmp, _i, _len, _ref;
      lineRoute = /Route\:/i;
      route = "";
      _ref = pkt.split('\r\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (lineRoute.test(line)) {
          tmp = line.split(': ');
          route += tmp[1] + "\r\nRoute: ";
        }
      }
      route = route.slice(0, -9);
      return {
        route: route
      };
    };

    Parser.parseContact = function(pkt) {
      var contactRE, gruuRE, result;
      contactRE = /Contact\:\s<(.*)>/g;
      gruuRE = /pub\-gruu=\"(.+?)\"/;
      result = this.getRegExprResult(pkt, contactRE, {
        contact: 1
      });
      return _.extend(result, this.getRegExprResult(pkt, gruuRE, {
        gruu: 1
      }));
    };

    Parser.parseCSeq = function(pkt) {
      var CSeqRE, cseq;
      CSeqRE = /CSeq\:\s(\d+)\s(.+)/gi;
      cseq = this.getRegExprResult(pkt, CSeqRE, {
        number: 1,
        meth: 2
      });
      cseq.number = parseInt(cseq.number);
      return {
        cseq: cseq
      };
    };

    Parser.parseChallenge = function(pkt) {
      var line, lineRe, nonce, nonceRe, realm, realmRe;
      lineRe = /^WWW-Authenticate\:.+$|^Proxy-Authenticate\:.+$/m;
      realmRe = /realm="(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|(([a-z]+\.)+[a-z]{2,3})|(\w+))"/;
      nonceRe = /nonce="(.{4,})"/;
      line = lineRe.exec(pkt);
      if (line != null) {
        line = line[0];
        realm = realmRe.exec(line)[1];
        nonce = nonceRe.exec(line)[1];
      }
      return {
        realm: realm,
        nonce: nonce
      };
    };

    Parser.parseExpires = function(pkt) {
      var expiresRE;
      expiresRE = /expires=(\d{1,4})/;
      return this.getRegExprResult(pkt, expiresRE, {
        proposedExpires: 1
      });
    };

    Parser.parseContentType = function(pkt) {
      var contentTypeRE;
      contentTypeRE = /Content-Type: (.*)/i;
      return this.getRegExprResult(pkt, contentTypeRE, {
        contentType: 1
      });
    };

    Parser.parseContent = function(pkt) {
      return {
        content: (pkt.split("\r\n\r\n"))[1]
      };
    };

    return Parser;

  })();

  window.Parser = Parser;

  SipTransaction = (function() {

    function SipTransaction(args) {
      this.set = __bind(this.set, this);

      var _base, _base1, _base2, _base3, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.set(args);
      if ((_ref = this.domainName) == null) {
        this.domainName = "" + (this.randomString(12)) + ".invalid";
      }
      if ((_ref1 = this.IP) == null) {
        this.IP = this.randomIP();
      }
      if ((_ref2 = this.branch) == null) {
        this.branch = "z9hG4bK" + this.randomString(30);
      }
      if (!(this.cseq != null)) {
        this.cseq = {};
        if ((_ref3 = (_base = this.cseq).number) == null) {
          _base.number = _.random(0, 1000);
        }
        if ((_ref4 = (_base1 = this.cseq).meth) == null) {
          _base1.meth = this.meth;
        }
        if ((_ref5 = (_base2 = this.cseq).meth) == null) {
          _base2.meth = "";
        }
      }
      if ((_ref6 = this.fromTag) == null) {
        this.fromTag = this.randomString(20);
      }
      if ((_ref7 = this.toTag) == null) {
        this.toTag = this.randomString(20);
      }
      if ((_ref8 = this.callId) == null) {
        this.callId = this.randomString(16);
      }
      this.regid = 1;
      if ((_ref9 = (_base3 = SipTransaction.prototype).uuid) == null) {
        _base3.uuid = this.getUuid();
      }
      if ((_ref10 = this.tupleId) == null) {
        this.tupleId = this.randomString(8);
      }
    }

    SipTransaction.prototype.set = function(args) {
      var key, value, _results;
      _results = [];
      for (key in args) {
        value = args[key];
        _results.push(this[key] = value);
      }
      return _results;
    };

    SipTransaction.prototype.randomString = function(n, hex) {
      var array, character, limit, string, _i, _len;
      if (hex == null) {
        hex = false;
      }
      if (hex) {
        string = Math.random().toString(16).slice(2);
      } else {
        string = Math.random().toString(32).slice(2);
        string = string.concat(Math.random().toString(32).toUpperCase().slice(2));
      }
      array = _.shuffle(string.split(""));
      string = "";
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        character = array[_i];
        string += character;
      }
      limit = Math.min(string.length, n);
      string = string.slice(0, limit);
      while (string.length < n) {
        string += this.randomString(n - string.length, hex);
      }
      return string.slice(0, n);
    };

    SipTransaction.prototype.getUuid = function() {
      if (localStorage["uuid"] === null || localStorage["uuid"] === void 0) {
        localStorage["uuid"] = "" + (this.randomString(3, true)) + "-" + (this.randomString(4, true)) + "-" + (this.randomString(8, true));
      }
      this.uuid = localStorage["uuid"];
      this.getUuid = function() {
        return this.uuid;
      };
      return this.uuid;
    };

    SipTransaction.prototype.randomIP = function() {
      var array, i, _i;
      array = [];
      for (i = _i = 0; _i <= 3; i = ++_i) {
        array.push(_.random(1, 255));
      }
      return array.join('.');
    };

    return SipTransaction;

  })();

  window.SipTransaction = SipTransaction;

  SipStack = (function(_super) {

    __extends(SipStack, _super);

    SipStack.prototype.addTransaction = function(transaction) {
      return this._transactions[transaction.branch] = transaction;
    };

    SipStack.prototype.getTransaction = function(message) {
      return this._transactions[message.branch];
    };

    SipStack.prototype.deleteTransaction = function(message) {
      return this._transactions = _.omit(this._transactions, message.branch);
    };

    SipStack.prototype.checkDialog = function(transaction) {
      var _this = this;
      return !_.isEmpty(_.find(this._transactions, function(tr) {
        var check;
        return check = tr.callId === transaction.callId;
      }));
    };

    SipStack.prototype.info = function(message, data) {
      console.log("[INFO]    " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.warning = function(message, data) {
      console.warn("[WARNING] " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.error = function(message, data) {
      console.error("[ERROR]   " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.states = ["OFFLINE", "REGISTERING (before challenge)", "REGISTERING (after challenge)", "REGISTERED", "INCOMING CALL", "CALLING", "RINGING", "CALL STABLISHED (caller)", "CALL STABLISHED (callee)", "HANGING", "CANCELLING"];

    SipStack.prototype.responsePhrases = {
      100: "Trying",
      180: "Ringing",
      200: "OK",
      202: "Accepted",
      400: "Bad Request",
      401: "Unauthorized",
      403: "Forbidden",
      404: "Not Found (User not found)",
      407: "Proxy Authentication Required",
      408: "Request Time Out",
      481: "Call/Transaction Does Not Exists",
      486: "Busy Here",
      488: "Not acceptable here",
      500: "Server Internal Error",
      503: "Service Unavaliable"
    };

    function SipStack() {
      this.setState = __bind(this.setState, this);

      this.publish = __bind(this.publish, this);

      this.getPidf = __bind(this.getPidf, this);

      this.subscribe = __bind(this.subscribe, this);

      this.sendInstantMessage = __bind(this.sendInstantMessage, this);

      this.sendWithSDP = __bind(this.sendWithSDP, this);

      this.send = __bind(this.send, this);

      this.hangup = __bind(this.hangup, this);

      this.answer = __bind(this.answer, this);

      this.call = __bind(this.call, this);

      this.register = __bind(this.register, this);

      this.createMessage = __bind(this.createMessage, this);

      this.getDigest = __bind(this.getDigest, this);

      this.error = __bind(this.error, this);

      this.warning = __bind(this.warning, this);

      this.info = __bind(this.info, this);

      this.checkDialog = __bind(this.checkDialog, this);

      this.deleteTransaction = __bind(this.deleteTransaction, this);

      this.getTransaction = __bind(this.getTransaction, this);

      this.addTransaction = __bind(this.addTransaction, this);

      var _ref, _ref1,
        _this = this;
      SipStack.__super__.constructor.apply(this, arguments);
      this.rtc = new RTC({
        mediaElements: this.mediaElements,
        mediaConstraints: this.mediaConstraints,
        turnServer: this.turnServer,
        stunServer: this.stunServer
      });
      this.rtc.bind("localstream", function(localstream) {
        return _this.trigger("localstream", localstream);
      });
      this.rtc.bind("remotestream", function(remotestream) {
        return _this.trigger("remotestream", remotestream);
      });
      this.sipServer = this.server.ip;
      this.port = this.server.port;
      this.path = this.server.path || "";
      this.transport = this.server.transport || "ws";
      this._transactions = {};
      this._instantMessages = {};
      this.setState(0);
      if ((_ref = this.hackViaTCP) == null) {
        this.hackViaTCP = false;
      }
      if ((_ref1 = this.hackIpContact) == null) {
        this.hackIpContact = false;
      }
      this.websocket = new WebSocket("" + this.transport + "://" + this.sipServer + ":" + this.port + this.path, "sip");
      console.log("" + this.transport + "://" + this.sipServer + ":" + this.port + this.path);
      this.info("websocket created");
      this.websocket.onopen = function(evt) {
        _this.info("websocket opened");
        return _this.onopen();
      };
      this.websocket.onmessage = function(evt) {
        var ack, busy, instantMessage, message, ok, register, ringing, transaction, _ref2, _ref3;
        message = Parser.parse(evt.data);
        _this.info("Input message", message);
        if ((_this.state > 2) && (message.cseq.meth === "REGISTER")) {
          if (!_this.getTransaction(message)) {
            return;
          }
          switch (message.responseCode) {
            case 200:
              _this.info("RE-REGISTER answer", message);
              return;
            case 401:
              register = _this.getTransaction(message);
              register.vias = message.vias;
              register.cseq.number += 1;
              _.extend(register, _.pick(message, "realm", "nonce", "toTag"));
              register.auth = true;
              _this.send(_this.createMessage(register));
              return;
          }
        }
        if (_this.state > 2 && message.cseq.meth === "MESSAGE") {
          switch (message.meth) {
            case "MESSAGE":
              console.log("[MESSAGE] " + message.content);
              instantMessage = {
                from: message.ext,
                to: message.ext2,
                content: message.content
              };
              _this.trigger("instant-message", instantMessage);
              _this.send(_this.createMessage(new SipTransaction(_.extend(message, {
                meth: "OK"
              }))));
              break;
            case "OK":
              console.log("[MESSAGE] OK");
              _this.deleteTransaction(message);
              break;
            default:
              if ((_ref2 = message.responseCode) !== 401 && _ref2 !== 407) {
                return;
              }
              if (!_this.getTransaction(message)) {
                return;
              }
              instantMessage = _this.getTransaction(message);
              _.extend(instantMessage, _.pick(message, "realm", "nonce", "toTag"));
              instantMessage.proxyAuth = message.responseCode === 407;
              instantMessage.auth = message.responseCode === 401;
              _this.send(_this.createMessage(instantMessage));
          }
          return;
        }
        if ((3 < (_ref3 = _this.state) && _ref3 < 9)) {
          if (message.meth === "INVITE") {
            _this.info("Another incoming call (BUSY)", message);
            busy = _.clone(message);
            _.extend(busy, {
              meth: "Busy here"
            });
            _this.send(_this.createMessage(busy));
            return;
          }
        }
        switch (_this.state) {
          case 1:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            transaction.vias = message.vias;
            switch (message.responseCode) {
              case 200:
                _this.info("register-success", message);
                _this.rtc.start();
                _this.setState(3, message);
                transaction.expires = message.proposedExpires / 2;
                _this.reRegister = function() {
                  var newRegister;
                  newRegister = _this.getTransaction(transaction);
                  newRegister.cseq.number += 1;
                  return _this.send(_this.createMessage(newRegister));
                };
                _this.t = setInterval(_this.reRegister, transaction.expires * 1000);
                _this.unregister = function() {
                  console.log("[INFO] unregistering");
                  transaction = _this.getTransaction(message);
                  transaction.expires = 0;
                  clearInterval(t);
                  message = _this.createMessage(transaction);
                  _this.send(message);
                  return _this.setState(0, message);
                };
                return _this.gruu = message.gruu;
              case 401:
                _this.setState(2, message);
                _.extend(transaction, _.pick(message, "realm", "nonce", "toTag"));
                transaction.cseq.number += 1;
                transaction.auth = true;
                return _this.send(_this.createMessage(transaction));
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 2:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            transaction.vias = message.vias;
            switch (message.responseCode) {
              case 200:
                _this.info("register-success", message);
                _this.rtc.start();
                _this.setState(3, message);
                transaction.expires = message.proposedExpires / 2;
                _this.reRegister = function() {
                  var newRegister;
                  newRegister = _this.getTransaction(transaction);
                  newRegister.cseq.number += 1;
                  return _this.send(_this.createMessage(newRegister));
                };
                _this.t = setInterval(_this.reRegister, transaction.expires * 1000);
                return _this.gruu = message.gruu;
              case 401:
                _this.info("register-fail", message);
                return _this.setState(0, message);
              default:
                _this.warning("message-unexpected", message);
                return _this.setState(0, message);
            }
            break;
          case 3:
            switch (message.meth) {
              case "INVITE":
                transaction = new SipTransaction(message);
                _this.addTransaction(transaction);
                ringing = _.clone(transaction);
                ringing.meth = "Ringing";
                _this.send(_this.createMessage(ringing));
                return _this.setState(6, message);
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 4:
            if (!_this.checkDialog(message)) {
              return;
            }
            switch (message.meth) {
              case "CANCEL":
                _this.info("Call ended");
                return _this.setState(3, message);
              case "ACK":
                return _this.setState(8, message);
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 5:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            switch (message.type) {
              case "response":
                if (_this.responsePhrases[message.responseCode]) {
                  _this.info(_this.responsePhrases[message.responseCode], message);
                } else {
                  _this.warning("Unexpected response", message);
                  return;
                }
                switch (message.responseCode) {
                  case 180:
                    return transaction.contact = message.contact;
                  case 200:
                    _this.info("Establishing call", message);
                    _this.rtc.receiveAnswer(message.content);
                    _.extend(transaction, _.pick(message, "from", "to", "fromTag", "toTag"));
                    ack = new SipTransaction(message);
                    ack.meth = "ACK";
                    _this.send(_this.createMessage(ack));
                    return _this.setState(7, message);
                  case 401:
                  case 407:
                    if (message.responseCode === 401) {
                      _this.info("AUTH", message);
                    }
                    if (message.responseCode === 407) {
                      _this.info("PROXY-AUTH", message);
                    }
                    ack = new SipTransaction(_.omit(message, "nonce"));
                    ack.meth = "ACK";
                    ack.vias = message.vias;
                    _this.send(_this.createMessage(ack));
                    transaction.vias = message.vias;
                    transaction.cseq.number += 1;
                    _.extend(transaction, _.pick(message, "realm", "nonce", "toTag"));
                    transaction.auth = message.responseCode === 401;
                    transaction.proxyAuth = message.responseCode === 407;
                    console.log(transaction);
                    message = _this.createMessage(transaction);
                    return _this.sendWithSDP(message, "offer", null);
                  default:
                    if (400 <= message.responseCode) {
                      ack = new SipTransaction(_.omit(message, "nonce"));
                      ack.meth = "ACK";
                      ack.vias = message.vias;
                      _this.send(_this.createMessage(ack));
                      _this.setState(3);
                      return _this.deleteTransaction("INVITE");
                    }
                }
                break;
              case "request":
                switch (message.meth) {
                  case "BYE":
                    _this.info("Call ended", message);
                    ok = new SipTransaction(message);
                    ok.meth = "OK";
                    _this.send(_this.createMessage(ok));
                    return _this.setState(3, message);
                  default:
                    return _this.warning("Unexpected message", message);
                }
            }
            break;
          case 6:
            if (!_this.checkDialog(message)) {
              return;
            }
            _this.info("RINGING", message);
            switch (message.meth) {
              case "CANCEL":
                _this.info("Call ended", message);
                ok = new SipTransaction(message);
                ok.meth = "OK";
                _this.send(_this.createMessage(ok));
                return _this.setState(3, message);
            }
            break;
          case 7:
          case 8:
            if (!_this.checkDialog(message)) {
              return;
            }
            _this.info("CALL ESTABLISHED", message);
            switch (message.meth) {
              case "BYE":
                _this.info("Call ended", message);
                transaction = new SipTransaction(message);
                transaction.vias = message.vias;
                transaction.meth = "OK";
                ok = _.clone(transaction);
                _this.send(_this.createMessage(ok));
                _this.rtc.close();
                return _this.setState(3, message);
            }
            break;
          case 9:
            if (!_this.getTransaction(message)) {
              return;
            }
            _this.info("HANGING UP", message);
            _this.info("Call ended", message);
            _this.rtc.close();
            return _this.setState(3, message);
          case 10:
            if (!_this.getTransaction(message)) {
              return;
            }
            _this.info("HANGING UP", message);
            _this.info("Call ended", message);
            return _this.setState(3, message);
        }
      };
      this.websocket.onclose = function(evt) {
        return _this.info("websocket closed");
      };
    }

    SipStack.prototype.getDigest = function(transaction) {
      var ha1, ha2, sol;
      ha1 = CryptoJS.MD5("" + transaction.ext + ":" + transaction.realm + ":" + transaction.pass);
      ha2 = CryptoJS.MD5("" + transaction.meth + ":" + transaction.requestUri);
      sol = CryptoJS.MD5("" + ha1 + ":" + transaction.nonce + ":" + ha2);
      return sol;
    };

    SipStack.prototype.createMessage = function(transaction) {
      var address, authUri, data, opaque, rr, _i, _len, _ref;
      transaction = new SipTransaction(transaction);
      transaction.uri = "sip:" + transaction.ext + "@" + (this.domain || this.sipServer);
      transaction.uri2 = "sip:" + transaction.ext2 + "@" + (transaction.domain2 || this.sipServer);
      transaction.targetUri = "sip:" + this.sipServer;
      if (transaction.meth === "BYE") {
        transaction.cseq.number += 1;
      }
      switch (transaction.meth) {
        case "REGISTER":
          transaction.requestUri = transaction.targetUri;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "PUBLISH":
          transaction.requestUri = transaction.uri;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "INVITE":
        case "MESSAGE":
        case "CANCEL":
        case "SUBSCRIBE":
          transaction.requestUri = transaction.uri2;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "ACK":
        case "BYE":
          transaction.requestUri = transaction.contact || transaction.uri2;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "OK":
          data = "SIP/2.0 200 OK\r\n";
          break;
        case "Ringing":
          data = "SIP/2.0 180 Ringing\r\n";
          break;
        case "Busy here":
          data = "SIP/2.0 486 Busy Here\r\n";
      }
      if ((transaction.cseq.meth === "INVITE" && transaction.meth !== "ACK") && (_.isArray(transaction.recordRoutes))) {
        _ref = transaction.recordRoutes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rr = _ref[_i];
          data += rr + "\r\n";
        }
      } else {
        switch (transaction.meth) {
          case "REGISTER":
          case "INVITE":
          case "MESSAGE":
          case "CANCEL":
          case "SUBSCRIBE":
          case "PUBLISH":
            data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr>\r\n";
            break;
          case "ACK":
          case "OK":
          case "BYE":
            if (transaction.cseq.meth !== "MESSAGE") {
              data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr=on>\r\n";
            }
        }
      }
      if (_.isArray(transaction.vias)) {
        data += (transaction.vias.join("\r\n")) + "\r\n";
      } else {
        data += "Via: SIP/2.0/" + ((this.hackViaTCP && "TCP") || this.transport.toUpperCase()) + " " + transaction.domainName + ";branch=" + transaction.branch + "\r\n";
      }
      data += "From: " + transaction.uri + ";tag=" + transaction.fromTag + "\r\n";
      switch (transaction.meth) {
        case "REGISTER":
        case "PUBLISH":
          data += "To: " + transaction.uri + "\r\n";
          break;
        case "INVITE":
        case "MESSAGE":
        case "CANCEL":
        case "SUBSCRIBE":
          data += "To: " + transaction.uri2 + "\r\n";
          break;
        default:
          data += "To: " + transaction.uri2 + ";tag=" + transaction.toTag + "\r\n";
      }
      data += "Call-ID: " + transaction.callId + "\r\n";
      switch (transaction.meth) {
        case "OK":
          data += "CSeq: " + transaction.cseq.number + " " + (transaction.cseq.meth || transaction.meth) + "\r\n";
          break;
        case "Ringing":
          data += "CSeq: " + transaction.cseq.number + " " + transaction.cseq.meth + "\r\n";
          break;
        case "ACK":
          data += "CSeq: " + transaction.cseq.number + " ACK\r\n";
          break;
        case "Busy here":
          data += "CSeq: " + transaction.cseq.number + " INVITE\r\n";
          break;
        default:
          data += "CSeq: " + transaction.cseq.number + " " + transaction.meth + "\r\n";
      }
      data += "Max-Forwards: 70\r\n";
      if (transaction.meth === "REGISTER" || transaction.meth === "INVITE") {
        data += "Allow: INVITE, ACK, CANCEL, BYE, MESSAGE, NOTIFY\r\n";
      }
      data += "Supported: path, outbound, gruu\r\n";
      data += "User-Agent: QoffeeSIP 0.5\r\n";
      address = (this.hackIpContact && transaction.IP) || transaction.domainName;
      switch (transaction.meth) {
        case "Ringing":
          if (this.gruu) {
            data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";gr=urn:uuid:" + transaction.uuid + ">\r\n";
          } else {
            data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";transport=ws>\r\n";
          }
          break;
        case "OK":
          if (transaction.cseq.meth === "INVITE") {
            if (this.gruu) {
              data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";gr=urn:uuid:" + transaction.uuid + ">\r\n";
            } else {
              data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";transport=ws>\r\n";
            }
          }
          break;
        case "REGISTER":
        case "PUBLISH":
          data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws>\r\n";
          break;
        case "INVITE":
        case "SUBSCRIBE":
          if (this.gruu) {
            data += "Contact: <" + this.gruu + ";ob>\r\n";
          } else {
            data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws;ob>\r\n";
          }
      }
      switch (transaction.meth) {
        case "REGISTER":
          data += ";reg-id=" + transaction.regid;
          data += ";+sip.instance=\"<urn:uuid:" + transaction.uuid + ">\"";
          if (transaction.expires != null) {
            data += ";expires=" + transaction.expires;
          }
          data += "\r\n";
      }
      if (transaction.nonce != null) {
        opaque = "";
        if (transaction.opaque != null) {
          opaque = "opaque=\"" + transaction.opaque + "\", ";
        }
        if (transaction.auth === true) {
          if (transaction.cseq.meth === "REGISTER") {
            authUri = transaction.targetUri;
          } else {
            authUri = transaction.uri2;
          }
          data += "Authorization:";
        }
        if (transaction.proxyAuth === true) {
          authUri = transaction.uri2;
          if (transaction.meth === "PUBLISH") {
            authUri = transaction.uri;
          }
          data += "Proxy-Authorization:";
        }
        transaction.response = this.getDigest(transaction);
        data += " Digest username=\"" + transaction.ext + "\",realm=\"" + transaction.realm + "\",";
        data += "nonce=\"" + transaction.nonce + "\"," + opaque + "uri=\"" + authUri + "\",response=\"" + transaction.response + "\",algorithm=MD5\r\n";
      }
      switch (transaction.meth) {
        case "SUBSCRIBE":
        case "PUBLISH":
          data += "Event: presence\r\n";
          if (transaction.meth === "SUBSCRIBE") {
            data += "Accept: application/pidf+xml\r\n";
          }
      }
      switch (transaction.meth) {
        case "INVITE":
        case "OK":
          if (transaction.cseq.meth === "INVITE") {
            data += "Content-Type: application/sdp\r\n";
          } else {
            data += "Content-Length: 0\r\n\r\n";
          }
          break;
        case "MESSAGE":
          data += "Content-Length: " + (transaction.content.length || 0) + "\r\n";
          data += "Content-Type: text/plain\r\n\r\n";
          data += transaction.content;
          break;
        case "PUBLISH":
          data += "Content-Length: " + (transaction.content.length || 0) + "\r\n";
          data += "Content-Type: application/pidf+xml\r\n\r\n";
          data += transaction.content;
          break;
        default:
          data += "Content-Length: 0\r\n\r\n";
      }
      return data;
    };

    SipStack.prototype.register = function(ext, pass, domain) {
      var message, transaction;
      this.ext = ext;
      this.pass = pass;
      this.domain = domain;
      transaction = new SipTransaction({
        meth: "REGISTER",
        ext: this.ext,
        domain: this.domain,
        pass: this.pass || ""
      });
      this.addTransaction(transaction);
      this.setState(1, transaction);
      message = this.createMessage(transaction);
      return this.send(message);
    };

    SipStack.prototype.call = function(ext2, domain2) {
      var message, transaction;
      transaction = new SipTransaction({
        meth: "INVITE",
        ext: this.ext,
        pass: this.pass,
        ext2: ext2,
        domain2: domain2 || this.domain
      });
      this.addTransaction(transaction);
      this.setState(5, transaction);
      message = this.createMessage(transaction);
      return this.sendWithSDP(message, "offer", null);
    };

    SipStack.prototype.answer = function(branch) {
      var ok;
      ok = _.clone(this.getTransaction({
        branch: branch
      }));
      ok.meth = "OK";
      this.sendWithSDP(this.createMessage(ok), "answer", this.getTransaction({
        branch: branch
      }).content);
      return this.setState(4, ok);
    };

    SipStack.prototype.hangup = function(branch) {
      var busy, bye, cancel, invite, swap;
      swap = function(d, p1, p2) {
        var _ref;
        return _ref = [d[p2], d[p1]], d[p1] = _ref[0], d[p2] = _ref[1], _ref;
      };
      invite = this.getTransaction({
        branch: branch
      });
      switch (this.state) {
        case 5:
          cancel = new SipTransaction({
            meth: "CANCEL",
            ext: this.ext,
            domain: this.domain,
            ext2: invite.ext2,
            domain2: invite.domain2
          });
          _.extend(cancel, _.pick(invite, "callId", "fromTag", "from", "to", "cseq", "domainName", "branch"));
          this.send(this.createMessage(cancel));
          return this.setState(10);
        case 6:
          busy = new SipTransaction({
            meth: "Busy here",
            ext: this.ext,
            ext2: invite.ext
          });
          _.extend(busy, _.pick(invite, "callId", "fromTag", "from", "to", "cseq", "domainName", "branch", "vias"));
          this.send(this.createMessage(busy));
          return this.setState(9, busy);
        case 7:
          bye = new SipTransaction({
            meth: "BYE",
            ext: this.ext,
            ext2: invite.ext2
          });
          _.extend(bye, _.pick(invite, "callId", "contact", "fromTag", "toTag", "from", "to", "cseq"));
          this.send(this.createMessage(bye));
          this.addTransaction(bye);
          this.setState(9, bye);
          return this.rtc.close();
        case 8:
          bye = new SipTransaction({
            meth: "BYE",
            ext: this.ext,
            ext2: invite.ext
          });
          _.extend(bye, _.pick(invite, "callId", "contact", "fromTag", "toTag", "from", "to", "cseq", "vias"));
          swap(bye, "fromTag", "toTag");
          swap(bye, "from", "to");
          this.send(this.createMessage(bye));
          this.addTransaction(bye);
          this.setState(9, bye);
          return this.rtc.close();
      }
    };

    SipStack.prototype.send = function(data) {
      if (data != null) {
        console.log("[INFO] Sending data", data);
        try {
          return this.websocket.send(data);
        } catch (e) {
          return this.error("websocket", e);
        }
      } else {
        return console.log("[INFO] Not sending data");
      }
    };

    SipStack.prototype.sendWithSDP = function(data, type, sdp) {
      var _this = this;
      this.rtc.bind("sdp", function(sdp) {
        data += "Content-Length: " + sdp.length + "\r\n\r\n";
        data += sdp;
        _this.send(data);
        return _this.rtc.unbind("sdp");
      });
      if (type === "offer") {
        this.rtc.createOffer();
      }
      if (type === "answer") {
        return this.rtc.receiveOffer(sdp, function() {
          return _this.rtc.createAnswer();
        });
      }
    };

    SipStack.prototype.sendInstantMessage = function(ext2, text) {
      var message;
      message = new SipTransaction({
        meth: "MESSAGE",
        ext: this.ext,
        pass: this.pass,
        ext2: ext2,
        content: text
      });
      this.addTransaction(message);
      return this.send(this.createMessage(message));
    };

    SipStack.prototype.subscribe = function(ext2, domain2) {
      var message, transaction;
      transaction = new SipTransaction({
        meth: "SUBSCRIBE",
        ext: this.ext,
        pass: this.pass,
        ext2: ext2,
        domain2: domain2 || this.domain
      });
      this.addTransaction(transaction);
      message = this.createMessage(transaction);
      return this.send(message);
    };

    SipStack.prototype.getPidf = function(status, ext, domain, tupleId) {
      var data, pstate;
      if (status === "Online") {
        pstate = "open";
      } else {
        pstate = "close";
      }
      data = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>";
      data = "<presence xmlns=\"urn:ietf:params:xml:ns:pidf\"\n";
      data += "\tentity=\"sip:" + ext + "@" + domain + "\">\n";
      data += "\t<tuple id=\"" + tupleId + "\">\n";
      data += "\t\t<status>\n";
      data += "\t\t\t<basic>" + pstate + "</basic>\n";
      data += "\t\t</status>\n";
      data += "\t\t<contact priority=\"0.8\">" + ext + "@" + domain + "</contact>\n";
      data += "\t</tuple>\n";
      return data += "</presence>";
    };

    SipStack.prototype.publish = function(status) {
      var message, transaction;
      transaction = new SipTransaction({
        meth: "PUBLISH",
        ext: this.ext,
        pass: this.pass,
        domain: this.domain
      });
      transaction.content = this.getPidf(status, this.ext, this.domain || this.sipServer, transaction.tupleId);
      this.addTransaction(transaction);
      message = this.createMessage(transaction);
      return this.send(message);
    };

    SipStack.prototype.setState = function(state, data) {
      this.state = state;
      console.log("[INFO] New state  " + this.states[this.state] + ("(" + this.state + ")"));
      return this.trigger("new-state", this.state, data);
    };

    return SipStack;

  })(Spine.Controller);

  window.SipStack = SipStack;

  API = (function(_super) {

    __extends(API, _super);

    function API(options) {
      this.attachStream = __bind(this.attachStream, this);

      this.toggleMuteAudio = __bind(this.toggleMuteAudio, this);

      this.toggleMuteVideo = __bind(this.toggleMuteVideo, this);

      this.off = __bind(this.off, this);

      this.on = __bind(this.on, this);

      this.publish = __bind(this.publish, this);

      this.subscribe = __bind(this.subscribe, this);

      this.chat = __bind(this.chat, this);

      this.unregister = __bind(this.unregister, this);

      this.hangup = __bind(this.hangup, this);

      this.answer = __bind(this.answer, this);

      this.call = __bind(this.call, this);

      this.register = __bind(this.register, this);
      API.__super__.constructor.apply(this, arguments);
      this.sipStack = new SipStack({
        server: this.server,
        stunServer: this.stunServer,
        turnServer: this.turnServer,
        hackViaTCP: this.hackViaTCP,
        hackIpContact: this.hackIpContact,
        mediaConstraints: this.mediaConstraints,
        mediaElements: this.mediaElements,
        onopen: this.onopen || function() {
          return false;
        }
      });
    }

    API.prototype.register = function(ext, pass, domain) {
      return this.sipStack.register(ext, pass, domain);
    };

    API.prototype.call = function(ext, domain) {
      return this.sipStack.call(ext, domain);
    };

    API.prototype.answer = function(branch) {
      return this.sipStack.answer(branch);
    };

    API.prototype.hangup = function(branch) {
      return this.sipStack.hangup(branch);
    };

    API.prototype.unregister = function() {
      return this.sipStack.unregister();
    };

    API.prototype.chat = function(ext, content) {
      return this.sipStack.sendInstantMessage(ext, content);
    };

    API.prototype.subscribe = function(ext, domain) {
      return this.sipStack.subscribe(ext, domain);
    };

    API.prototype.publish = function(pstatus, domain) {
      return this.sipStack.publish(pstatus);
    };

    API.prototype.on = function(eventName, callback) {
      return this.sipStack.bind(eventName, callback);
    };

    API.prototype.off = function(eventName, callback) {
      return this.sipStack.unbind(eventName, callback);
    };

    API.prototype.toggleMuteVideo = function() {
      return this.sipStack.rtc.toggleMuteVideo();
    };

    API.prototype.toggleMuteAudio = function() {
      return this.sipStack.rtc.toggleMuteAudio();
    };

    API.prototype.attachStream = function($d, stream) {
      return this.sipStack.rtc.attachStream($d, stream);
    };

    return API;

  })(Spine.Controller);

  window.API = API;

}).call(this);
