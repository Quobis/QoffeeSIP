/*
@source: https://github.com/Quobis/QoffeeSIP
Copyright (C) Quobis
Licensed under GNU-LGPL-3.0-or-later (http://www.gnu.org/licenses/lgpl-3.0.html)
*/
// Generated by CoffeeScript 1.4.0
(function() {
  var AugumentedStatsResponse, Parser, QS, RTC, RTCIceCandidate, RTCPeerConnection, RTCSessionDescription, SipStack, SipTransaction, attachMediaStream, createIceServer, getUserMedia, reattachMediaStream, webrtcDetectedBrowser, webrtcDetectedVersion,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  RTCPeerConnection = null;

  RTCSessionDescription = null;

  RTCIceCandidate = null;

  getUserMedia = null;

  attachMediaStream = null;

  createIceServer = null;

  reattachMediaStream = null;

  webrtcDetectedBrowser = null;

  webrtcDetectedVersion = null;

  if (navigator.mozGetUserMedia) {
    console.log("This appears to be Firefox");
    webrtcDetectedBrowser = "firefox";
    webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
    RTCPeerConnection = mozRTCPeerConnection;
    RTCSessionDescription = mozRTCSessionDescription;
    RTCIceCandidate = mozRTCIceCandidate;
    getUserMedia = navigator.mozGetUserMedia.bind(navigator);
    createIceServer = function(url, username, password) {
      var iceServer, turn_url_parts, url_parts;
      iceServer = null;
      url_parts = url.split(":");
      if (url_parts[0].indexOf("stun") === 0) {
        iceServer = {
          url: url
        };
      } else if (url_parts[0].indexOf("turn") === 0) {
        if (webrtcDetectedVersion < 27) {
          turn_url_parts = url.split("?");
          if (turn_url_parts[1].indexOf("transport=udp") === 0) {
            iceServer = {
              url: turn_url_parts[0],
              credential: password,
              username: username
            };
          }
        } else {
          iceServer = {
            url: url,
            credential: password,
            username: username
          };
        }
      }
      return iceServer;
    };
    attachMediaStream = function(element, stream) {
      console.log("Attaching media stream");
      element.mozSrcObject = stream;
      return element.play();
    };
    reattachMediaStream = function(to, from) {
      console.log("Reattaching media stream");
      to.mozSrcObject = from.mozSrcObject;
      return to.play();
    };
    MediaStream.prototype.getVideoTracks = function() {
      return [];
    };
    MediaStream.prototype.getAudioTracks = function() {
      return [];
    };
  } else if (navigator.webkitGetUserMedia) {
    console.log("This appears to be Chrome");
    webrtcDetectedBrowser = "chrome";
    webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
    createIceServer = function(url, username, password) {
      var iceServer, url_parts;
      iceServer = null;
      url_parts = url.split(":");
      if (url_parts[0].indexOf("stun") === 0) {
        iceServer = {
          url: url
        };
      } else if (url_parts[0].indexOf("turn") === 0) {
        iceServer = {
          url: url,
          credential: password,
          username: username
        };
      }
      return iceServer;
    };
    RTCPeerConnection = webkitRTCPeerConnection;
    RTCSessionDescription = window.RTCSessionDescription;
    RTCIceCandidate = window.RTCIceCandidate;
    getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
    attachMediaStream = function(element, stream) {
      if (typeof element.srcObject !== "undefined") {
        return element.srcObject = stream;
      } else if (typeof element.mozSrcObject !== "undefined") {
        return element.mozSrcObject = stream;
      } else if (typeof element.src !== "undefined") {
        return element.src = URL.createObjectURL(stream);
      } else {
        return console.log("Error attaching stream to element.");
      }
    };
    reattachMediaStream = function(to, from) {
      return to.src = from.src;
    };
  } else {
    console.log("Browser does not appear to be WebRTC-capable");
  }

  window.RTCAdapter = {
    RTCPeerConnection: RTCPeerConnection,
    RTCSessionDescription: RTCSessionDescription,
    RTCIceCandidate: RTCIceCandidate,
    getUserMedia: getUserMedia,
    attachMediaStream: attachMediaStream,
    createIceServer: createIceServer,
    webrtcDetectedBrowser: webrtcDetectedBrowser,
    webrtcDetectedVersion: webrtcDetectedVersion
  };

  Promise.of = function(value) {
    return new Promise(function(resolve, reject) {
      return resolve(value);
    });
  };

  Promise.prototype.map = function(f) {
    var _this = this;
    return new Promise(function(resolve, _) {
      return _this.then(function(a) {
        return resolve(f(a));
      });
    });
  };

  Promise.prototype.rejectedMap = function(f) {
    var _this = this;
    return new Promise(function(_, reject) {
      return _this.then(function(a) {
        return reject(f(a));
      });
    });
  };

  AugumentedStatsResponse = (function() {

    function AugumentedStatsResponse(response) {
      this.response = response;
      this.get = __bind(this.get, this);

      this.result = __bind(this.result, this);

      this.collectAddressPairs = __bind(this.collectAddressPairs, this);

    }

    AugumentedStatsResponse.prototype.addressPairMap = [];

    AugumentedStatsResponse.prototype.collectAddressPairs = function(componentId) {
      var res, results, _i, _len;
      if (!this.addressPairMap[componentId]) {
        this.addressPairMap[componentId] = [];
        results = this.response.result();
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          res = results[_i];
          if (res.type === 'googCandidatePair' && res.stat('googChannelId') === componentId) {
            this.addressPairMap[componentId].push(res);
          }
        }
      }
      return this.addressPairMap[componentId];
    };

    AugumentedStatsResponse.prototype.result = function() {
      return this.response.result();
    };

    AugumentedStatsResponse.prototype.get = function(key) {
      return this.response[key];
    };

    return AugumentedStatsResponse;

  })();

  RTC = (function(_super) {

    __extends(RTC, _super);

    RTC.include(Spine.Events);

    function RTC(args) {
      this.insertDTMF = __bind(this.insertDTMF, this);

      this.mediaState = __bind(this.mediaState, this);

      this.toggleMuteVideo = __bind(this.toggleMuteVideo, this);

      this.unmuteVideo = __bind(this.unmuteVideo, this);

      this.muteVideo = __bind(this.muteVideo, this);

      this.unmuteAudio = __bind(this.unmuteAudio, this);

      this.muteAudio = __bind(this.muteAudio, this);

      this.toggleMuteAudio = __bind(this.toggleMuteAudio, this);

      this.close = __bind(this.close, this);

      this.receiveAnswer = __bind(this.receiveAnswer, this);

      this.receiveOffer = __bind(this.receiveOffer, this);

      this.receive = __bind(this.receive, this);

      this.createAnswer = __bind(this.createAnswer, this);

      this.createOffer = __bind(this.createOffer, this);

      this.setLocalDescription = __bind(this.setLocalDescription, this);

      this.triggerSDP = __bind(this.triggerSDP, this);

      this.createScreenStream = __bind(this.createScreenStream, this);

      this.createStream = __bind(this.createStream, this);

      this.createPeerConnection = __bind(this.createPeerConnection, this);

      this.addIceServer = __bind(this.addIceServer, this);

      this.getStats = __bind(this.getStats, this);

      this.getRemoteStreamEventName = __bind(this.getRemoteStreamEventName, this);

      this.start = __bind(this.start, this);

      var key, value, _ref;
      console.log("[INFO] RTC constructor");
      for (key in args) {
        value = args[key];
        this[key] = value;
      }
      if ((_ref = this.mediaConstraints) == null) {
        this.mediaConstraints = {
          audio: true,
          video: true,
          screensharing: false
        };
      }
      this.isVideoActive = true;
      this.isAudioActive = true;
      this.iceServers = [];
      if ((this.iceServer != null) && (this.iceServer !== "")) {
        this.iceServers.push(this.iceServer);
      }
    }

    RTC.prototype.pcOptions = {
      optional: [
        {
          DtlsSrtpKeyAgreement: true
        }, {
          RtpDataChannels: true
        }
      ]
    };

    RTC.prototype.screenConstraints = {
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: 'screen',
          maxWidth: 1280,
          maxHeight: 720
        },
        optional: []
      }
    };

    RTC.prototype.start = function() {
      var _this = this;
      if (this.pc != null) {
        return Promise.of(this.pc);
      }
      return new Promise(function(resolve, reject) {
        var localStreamPromise;
        _this.pc = _this.createPeerConnection();
        console.log("PeerConnection starting");
        _this.noMoreCandidates = navigator.mozGetUserMedia != null;
        _this.dtmfSender = null;
        localStreamPromise = _this.createStream();
        return localStreamPromise.then(function(stream) {
          _this.pc.addStream(stream);
          return resolve(_this.pc);
        });
      });
    };

    RTC.prototype.dumpStats = function(obj) {
      var dict, names, properties, values;
      dict = {};
      dict = _.pick(obj, "timestamp", "id", "type");
      properties = {};
      if (obj.names) {
        names = obj.names();
        values = _.map(names, function(x) {
          return obj.stat(x);
        });
        properties = _.object(names, values);
      } else if (obj.stat("audioOutputLevel")) {
        properties = {
          audioOutputLevel: obj.stat("audioOutputLevel")
        };
      }
      return _.extend(dict, properties);
    };

    RTC.prototype.getRemoteStreamEventName = function(stream) {
      if (stream.getAudioTracks().length) {
        return "remotestream";
      } else {
        return "remotestream-screen";
      }
    };

    RTC.prototype.getStats = function(cb) {
      var _ref,
        _this = this;
      if (!((this.pc != null) && ((_ref = this.pc.readyState) === "stable" || _ref === "active") && (cb != null))) {
        return;
      }
      return this.pc.getStats(function(rawStats) {
        var results, stats;
        stats = new AugumentedStatsResponse(rawStats);
        results = stats.result();
        return cb(_.compact(_.map(results, function(result) {
          var local, remote, report;
          report = null;
          if (!result.local || result.local === result) {
            report = _this.dumpStats(result);
            if (result.local && result.local !== result) {
              local = {
                local: _this.dumpStats(result.local)
              };
            }
            if (result.remote && result.remote !== result) {
              remote = {
                remote: _this.dumpStats(result.remote)
              };
            }
            return _.extend(report, local || {}, remote || {});
          }
          return null;
        })));
      });
    };

    RTC.prototype.addIceServer = function(url, username, password) {
      return this.iceServers.push(RTCAdapter.createIceServer(url, username, password));
    };

    RTC.prototype.createPeerConnection = function(locastream) {
      var iceGatheringEndCb, pc,
        _this = this;
      console.log("[INFO] createPeerConnection");
      console.log("[MEDIA] ICE servers");
      console.log(this.iceServers);
      pc = new RTCAdapter.RTCPeerConnection({
        "iceServers": this.iceServers
      }, this.pcOptions);
      pc.onaddstream = function(event) {
        var remotestream;
        console.log("[MEDIA] Stream added");
        remotestream = event.stream;
        return _this.trigger(_this.getRemoteStreamEventName(remotestream), remotestream);
      };
      iceGatheringEndCb = function() {
        console.log("[INFO] No more ice candidates");
        _this.noMoreCandidates = true;
        if (pc.localDescription != null) {
          return _this.triggerSDP();
        }
      };
      pc.onicecandidate = function(evt) {
        var candidate;
        console.log("[INFO] onicecandidate");
        if (evt.candidate) {
          console.log("[INFO] New ICE candidate:");
          console.log("" + evt.candidate.candidate);
          return candidate = {
            type: 'candidate',
            label: evt.candidate.sdpMLineIndex,
            id: evt.candidate.sdpMid,
            candidate: evt.candidate.candidate
          };
        } else {
          return iceGatheringEndCb();
        }
      };
      pc.oniceconnectionstatechange = function(evt) {
        if (evt.currentTarget.iceGatheringState === 'complete' && pc.iceConnectionState !== 'closed') {
          console.log("[INFO] iceGatheringState -> " + evt.currentTarget.iceGatheringState);
          return iceGatheringEndCb();
        }
      };
      pc.onicechange = function() {
        return console.log("[INFO] icestate changed -> " + pc.iceState);
      };
      pc.onstatechange = function() {
        return console.log("[INFO] peerconnectionstate changed -> " + pc.readyState);
      };
      pc.onopen = function() {
        return console.log("[MEDIA] peerconnection opened");
      };
      pc.onclose = function() {
        return console.log("[INFO] peerconnection closed");
      };
      return pc;
    };

    RTC.prototype.createStream = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var gumFail, gumSuccess;
        console.log("[INFO] createStream");
        if (_this.localstream != null) {
          console.log("[INFO] Using media previously got.");
          return resolve(_this.localstream);
        } else {
          gumSuccess = function(localstream) {
            var _ref;
            _this.localstream = localstream;
            console.log("[INFO] getUserMedia successed");
            resolve(_this.localstream);
            _this.trigger("localstream", _this.localstream);
            console.log("localstream", _this.localstream);
            return _ref = [_this.localstream.getVideoTracks().length > 0, _this.localstream.getAudioTracks().length > 0], _this.isVideoActive = _ref[0], _this.isAudioActive = _ref[1], _ref;
          };
          gumFail = function(error) {
            reject(error);
            console.error(error);
            console.error("GetUserMedia error");
            return _this.trigger("error", "getUserMedia");
          };
          return RTCAdapter.getUserMedia(_this.mediaConstraints, gumSuccess, gumFail);
        }
      });
    };

    RTC.prototype.createScreenStream = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var gumFail, gumSuccess;
        if (webrtcDetectedBrowser !== 'chrome') {
          reject();
        }
        console.log("[INFO] createScreenStream");
        if (_this.localScreenStream != null) {
          console.log("[INFO] Using media previously got.");
          return resolve(localScreenStream);
        } else {
          gumSuccess = function(localScreenStream) {
            _this.localScreenStream = localScreenStream;
            console.log("[INFO] getUserMedia successed");
            resolve(_this.localScreenStream);
            _this.trigger("localstream-screen", _this.localScreenStream);
            return console.log("localstream-screen", _this.localScreenStream);
          };
          gumFail = function(error) {
            reject(error);
            console.error(error);
            console.error("GetUserMedia error");
            return _this.trigger("error", "getUserMedia");
          };
          return RTCAdapter.getUserMedia(_this.screenConstraints, gumSuccess, gumFail);
        }
      });
    };

    RTC.prototype.triggerSDP = function() {
      var sdp;
      console.log("[SDP]");
      sdp = this.pc.localDescription.sdp;
      console.log(sdp);
      return this.trigger("sdp", sdp);
    };

    RTC.prototype.setLocalDescription = function(sessionDescription) {
      var fail, success,
        _this = this;
      success = function() {
        console.log("[INFO] setLocalDescription successed");
        if (_this.noMoreCandidates) {
          return _this.triggerSDP();
        }
      };
      fail = function() {
        return _this.trigger("error", "setLocalDescription", sessionDescription);
      };
      return this.pc.setLocalDescription(sessionDescription, success, fail);
    };

    RTC.prototype.createOffer = function() {
      var _this = this;
      console.log("[INFO] createOffer");
      return this.start().then(function(pc) {
        var error;
        error = function(e) {
          return _this.trigger("error", "createOffer", e);
        };
        return pc.createOffer(_this.setLocalDescription, error, {});
      });
    };

    RTC.prototype.createAnswer = function() {
      var error,
        _this = this;
      console.log("[INFO] Answer");
      error = function(e) {
        return _this.trigger("error", "createOffer", e);
      };
      return this.pc.createAnswer(this.setLocalDescription, error, {});
    };

    RTC.prototype.receive = function(sdp, type, callback) {
      var _this = this;
      return this.start().then(function(pc) {
        var description, success;
        console.log("[INFO] receive!");
        console.log(sdp, type, callback);
        success = function() {
          console.log("[INFO] Remote description setted.");
          console.log("[INFO] localDescription:");
          console.log(pc.localDescription);
          console.log("[INFO] remotelocalDescription:");
          console.log(pc.remoteDescription);
          return typeof callback === "function" ? callback() : void 0;
        };
        description = new RTCAdapter.RTCSessionDescription({
          type: type,
          sdp: sdp
        });
        console.log(description);
        return pc.setRemoteDescription(description, success, function() {
          return _this.trigger("error", "setRemoteDescription", description);
        });
      });
    };

    RTC.prototype.receiveOffer = function(sdp, callback) {
      if (callback == null) {
        callback = null;
      }
      console.log("[INFO] Received offer");
      return this.receive(sdp, "offer", callback);
    };

    RTC.prototype.receiveAnswer = function(sdp, callback) {
      if (callback == null) {
        callback = null;
      }
      console.log("[INFO] Received answer");
      return this.receive(sdp, "answer", callback);
    };

    RTC.prototype.close = function() {
      try {
        this.pc.close();
        return this.dtmfSender = null;
      } catch (e) {
        console.error("[ERROR] Error closing peerconnection");
        return console.error(e);
      } finally {
        this.pc = null;
        this.start();
      }
    };

    RTC.prototype.toggleMuteAudio = function() {
      var audioTracks;
      audioTracks = this.localstream.getAudioTracks();
      if (audioTracks.length === 0) {
        console.log("[MEDIA] No local audio available.");
        return;
      }
      if (this.isAudioActive) {
        return this.muteAudio();
      } else {
        return this.unmuteAudio();
      }
    };

    RTC.prototype.muteAudio = function() {
      var audioTrack, audioTracks, _i, _len;
      audioTracks = this.localstream.getAudioTracks();
      for (_i = 0, _len = audioTracks.length; _i < _len; _i++) {
        audioTrack = audioTracks[_i];
        audioTrack.enabled = false;
      }
      return this.isAudioActive = false;
    };

    RTC.prototype.unmuteAudio = function() {
      var audioTrack, audioTracks, _i, _len;
      audioTracks = this.localstream.getAudioTracks();
      for (_i = 0, _len = audioTracks.length; _i < _len; _i++) {
        audioTrack = audioTracks[_i];
        audioTrack.enabled = true;
      }
      return this.isAudioActive = true;
    };

    RTC.prototype.muteVideo = function() {
      var videoTrack, videoTracks, _i, _len;
      videoTracks = this.localstream.getVideoTracks();
      for (_i = 0, _len = videoTracks.length; _i < _len; _i++) {
        videoTrack = videoTracks[_i];
        videoTrack.enabled = false;
      }
      return this.isVideoActive = false;
    };

    RTC.prototype.unmuteVideo = function() {
      var videoTrack, videoTracks, _i, _len;
      videoTracks = this.localstream.getVideoTracks();
      for (_i = 0, _len = videoTracks.length; _i < _len; _i++) {
        videoTrack = videoTracks[_i];
        videoTrack.enabled = true;
      }
      return this.isVideoActive = true;
    };

    RTC.prototype.toggleMuteVideo = function() {
      var videoTracks;
      videoTracks = this.localstream.getVideoTracks();
      if (videoTracks.length === 0) {
        console.log("[MEDIA] No local audio available.");
        return;
      }
      if (this.isVideoActive) {
        return this.muteVideo();
      } else {
        return this.unmuteVideo();
      }
    };

    RTC.prototype.mediaState = function() {
      return {
        video: Boolean(this.isVideoActive),
        audio: Boolean(this.isAudioActive)
      };
    };

    RTC.prototype.insertDTMF = function(tone) {
      if (this.dtmfSender != null) {
        return this.dtmfSender.insertDTMF(tone, 500, 50);
      }
    };

    RTC.attachStream = function($d, stream) {
      return RTCAdapter.attachMediaStream($d[0], stream);
    };

    return RTC;

  })(Spine.Module);

  window.RTC = RTC;

  Parser = (function() {

    function Parser() {}

    Parser.getRegExprResult = function(pkt, re, indexes) {
      var index, key, line, result, _i, _len, _ref;
      result = {};
      _ref = _.keys(indexes);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        result[key] = void 0;
      }
      line = re.exec(pkt);
      if (line != null) {
        for (key in indexes) {
          index = indexes[key];
          if (index < line.length) {
            result[key] = line[index];
          }
        }
      }
      return result;
    };

    Parser.parse = function(pkt) {
      var message;
      console.log("[INFO] Parsing");
      console.log(pkt);
      message = {};
      _.extend(message, {
        frame: pkt
      });
      _.extend(message, this.parseFirstLine(pkt));
      _.extend(message, this.parseVias(pkt));
      _.extend(message, this.parseFrom(pkt));
      _.extend(message, this.parseTo(pkt));
      _.extend(message, this.parseRecordRoutes(pkt));
      _.extend(message, this.parseRoute(pkt));
      _.extend(message, this.parseContact(pkt));
      _.extend(message, this.parseCallId(pkt));
      _.extend(message, this.parseCSeq(pkt));
      _.extend(message, this.parseChallenge(pkt));
      _.extend(message, this.parseExpires(pkt));
      _.extend(message, this.parseContentType(pkt));
      _.extend(message, this.parseContent(pkt));
      console.log("[INFO] Parsed");
      console.log(message);
      return message;
    };

    Parser.parseFirstLine = function(pkt) {
      var code, firstLine, meth, methodRE, requestUri, responseRE, tmp;
      firstLine = pkt.split("\r\n")[0];
      responseRE = /^SIP\/2\.0 \d+/;
      if (responseRE.test(firstLine)) {
        tmp = firstLine.split(" ");
        tmp = _.rest(tmp);
        code = parseInt(tmp[0]);
        tmp = _.rest(tmp);
        meth = tmp.join(" ");
        return {
          responseCode: code,
          meth: meth,
          type: "response"
        };
      } else {
        methodRE = /(\w+)/;
        meth = methodRE.exec(firstLine)[0];
        requestUri = firstLine.split(" ")[1].split(";")[0];
        return {
          meth: meth,
          type: "request"
        };
      }
    };

    Parser.parseVias = function(pkt) {
      var branchRE, ret, tmp, viaRE, vias;
      viaRE = /Via\:\s+SIP\/2\.0\/[A-Z]+\s+([A-z0-9\.\:]+)/;
      tmp = _.filter(pkt.split("\r\n"), function(line) {
        return viaRE.test(line);
      });
      vias = _.map(tmp, function(via) {
        return via.replace(/;received=[A-z0-9\.\:]+/, "");
      });
      console.log(vias);
      if (vias.length > 0) {
        ret = this.getRegExprResult(vias[0], viaRE, {
          sentBy: 1
        });
        branchRE = /branch=([^;\s]+)/;
        ret = this.getRegExprResult(vias[0], branchRE, {
          branch: 1
        });
      }
      console.log(_.extend({
        vias: vias
      }, ret));
      return _.extend({
        vias: vias
      }, ret);
    };

    Parser.parseRecordRoutes = function(pkt) {
      var recordRouteRE, recordRoutes;
      recordRouteRE = /Record-Route\:/i;
      recordRoutes = _.filter(pkt.split("\r\n"), function(line) {
        return recordRouteRE.test(line);
      });
      return {
        recordRoutes: recordRoutes
      };
    };

    Parser.parseFrom = function(pkt) {
      var displayName, lineFrom, lineFromRE, tag, user, useruri;
      lineFromRE = /(From|^f):\s*(((\"[a-zA-Z0-9\-\.\!\%\*\+\`\'\~\s]+\"|[a-zA-Z0-9\-\.\!\%\*\+\`\'\~]+)\s*<([^>]*)>)|<([^>]*)>|([^;\r\n]*))(;.*)?/;
      if (!((lineFrom = lineFromRE.exec(pkt)) != null)) {
        console.error("Error parsing From!!");
      } else {
        useruri = lineFrom[5] || lineFrom[6] || lineFrom[7];
        displayName = lineFrom[4];
        tag = lineFrom[8];
        user = /sips?:((.+)@[a-zA-Z0-9\.\-]+(\:[0-9]+)?)/.exec(useruri)[2];
      }
      return {
        from: useruri,
        ext: user,
        fromTag: tag,
        displayNameFrom: displayName
      };
    };

    Parser.parseTo = function(pkt) {
      var displayName, lineTo, lineToRE, tag, user, useruri;
      lineToRE = /(To|^t):\s*(((\"[a-zA-Z0-9\-\.\!\%\*\+\`\'\~\s]+\"|[a-zA-Z0-9\-\.\!\%\*\+\`\'\~]+)\s*<([^>]*)>)|<([^>]*)>|([^;\r\n]*))(;.*)?/;
      if (!((lineTo = lineToRE.exec(pkt)) != null)) {
        console.error("Error parsing To!!");
      } else {
        useruri = lineTo[5] || lineTo[6] || lineTo[7];
        displayName = lineTo[4];
        tag = lineTo[8];
        user = /sips?:((.+)@[a-zA-Z0-9\.\-]+(\:[0-9]+)?)/.exec(useruri)[2];
      }
      return {
        to: useruri,
        ext2: user,
        toTag: tag,
        displayNameTo: displayName
      };
    };

    Parser.parseCallId = function(pkt) {
      var lineCallIdRE;
      lineCallIdRE = /Call-ID:\s(.+)/i;
      return this.getRegExprResult(pkt, lineCallIdRE, {
        callId: 1
      });
    };

    Parser.parseRoute = function(pkt) {
      var line, lineRoute, route, tmp, _i, _len, _ref;
      lineRoute = /Route\:/i;
      route = "";
      _ref = pkt.split('\r\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (lineRoute.test(line)) {
          tmp = line.split(': ');
          route += tmp[1] + "\r\nRoute: ";
        }
      }
      route = route.slice(0, -9);
      return {
        route: route
      };
    };

    Parser.parseContact = function(pkt) {
      var contactRE, gruuRE, result, result2;
      contactRE = /(Contact|^m):\s*(\"[a-zA-Z0-9\-\.\!\%\*\+\`\'\~]*\"|[^<]*)\s*<?((sips?:((.+)@[a-zA-Z0-9\.\-]+(\:[0-9]+)?))([a-zA-Z0-9\-\.\!\%\*\+\`\'\~\;\=]*))>?(.*)/;
      gruuRE = /pub\-gruu=\"(.+?)\"/;
      result = this.getRegExprResult(pkt, contactRE, {
        contact: 3
      });
      result2 = this.getRegExprResult(pkt, contactRE, {
        contact: 8
      });
      console.warn(result);
      console.warn(result2);
      return _.extend(result, this.getRegExprResult(pkt, gruuRE, {
        gruu: 1
      }));
    };

    Parser.parseCSeq = function(pkt) {
      var CSeqRE, cseq;
      CSeqRE = /CSeq\:\s(\d+)\s(.+)/gi;
      cseq = this.getRegExprResult(pkt, CSeqRE, {
        number: 1,
        meth: 2
      });
      cseq.number = parseInt(cseq.number);
      return {
        cseq: cseq
      };
    };

    Parser.parseChallenge = function(pkt) {
      var line, lineRe, nonce, nonceRe, opaque, opaqueRe, qop, qopRe, realm, realmRe, _ref, _ref1, _ref2, _ref3;
      lineRe = /^WWW-Authenticate\:.+$|^Proxy-Authenticate\:.+$/m;
      realmRe = /realm="([^\"^\\]+)"/;
      nonceRe = /nonce="([^\"^\\]+)"/;
      opaqueRe = /opaque="([^\"^\\]+)"/;
      qopRe = /qop=\"(auth|auth-int)\"/;
      line = lineRe.exec(pkt);
      if (line != null) {
        realm = (_ref = realmRe.exec(pkt)) != null ? _ref[1] : void 0;
        nonce = (_ref1 = nonceRe.exec(pkt)) != null ? _ref1[1] : void 0;
        opaque = (_ref2 = opaqueRe.exec(pkt)) != null ? _ref2[1] : void 0;
        qop = (_ref3 = qopRe.exec(pkt)) != null ? _ref3[1] : void 0;
      }
      return {
        realm: realm,
        nonce: nonce,
        opaque: opaque,
        qop: qop
      };
    };

    Parser.parseExpires = function(pkt) {
      var expiresRE;
      expiresRE = /expires=(\d{1,4})/;
      return this.getRegExprResult(pkt, expiresRE, {
        proposedExpires: 1
      });
    };

    Parser.parseContentType = function(pkt) {
      var contentTypeRE;
      contentTypeRE = /Content-Type: (.*)/i;
      return this.getRegExprResult(pkt, contentTypeRE, {
        contentType: 1
      });
    };

    Parser.parseContent = function(pkt) {
      return {
        content: (pkt.split("\r\n\r\n"))[1]
      };
    };

    return Parser;

  })();

  window.Parser = Parser;

  SipTransaction = (function() {

    function SipTransaction(args) {
      this.set = __bind(this.set, this);

      var _base, _base1, _base2, _base3, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.set(args);
      if (this.uri) {
        _ref = this.uri.split("@"), this.ext = _ref[0], this.domain = _ref[1];
      }
      if (this.uri2) {
        _ref1 = this.uri2.split("@"), this.ext2 = _ref1[0], this.domain2 = _ref1[1];
      }
      if ((_ref2 = this.domainName) == null) {
        this.domainName = "" + (this.randomString(12)) + ".invalid";
      }
      if ((_ref3 = this.IP) == null) {
        this.IP = this.randomIP();
      }
      if ((_ref4 = this.branch) == null) {
        this.branch = "z9hG4bK" + this.randomString(30);
      }
      if (!(this.cseq != null)) {
        this.cseq = {};
        if ((_ref5 = (_base = this.cseq).number) == null) {
          _base.number = _.random(0, 1000);
        }
        if ((_ref6 = (_base1 = this.cseq).meth) == null) {
          _base1.meth = this.meth;
        }
        if ((_ref7 = (_base2 = this.cseq).meth) == null) {
          _base2.meth = "";
        }
      }
      if ((args.toTag != null) && !/^;tag=/.test(args.toTag)) {
        this.toTag = ";tag=" + args.toTag;
      }
      if ((args.fromTag != null) && !/^;tag=/.test(args.fromTag)) {
        this.fromTag = ";tag=" + args.fromTag;
      }
      if ((_ref8 = this.fromTag) == null) {
        this.fromTag = ";tag=" + this.randomString(20);
      }
      if ((_ref9 = this.toTag) == null) {
        this.toTag = ";tag=" + this.randomString(20);
      }
      if ((args.userAuthName != null) && args.userAuthName !== "") {
        this.userAuthName = args.userAuthName;
        console.log("Using provided userAuthName for authentication: " + args.userAuthName);
      } else {
        this.userAuthName = args.ext;
        console.log("Using user name for authentication: " + args.ext);
      }
      if (args.to != null) {
        if ((_ref10 = this.domain2) == null) {
          this.domain2 = args.to.split("@")[1];
        }
      }
      if ((_ref11 = this.callId) == null) {
        this.callId = this.randomString(16);
      }
      this.regid = 1;
      if ((_ref12 = (_base3 = SipTransaction.prototype).uuid) == null) {
        _base3.uuid = this.getUuid();
      }
      if ((_ref13 = this.tupleId) == null) {
        this.tupleId = this.randomString(8);
      }
      if ((_ref14 = this.cnonce) == null) {
        this.cnonce = "";
      }
      if ((_ref15 = this.nc) == null) {
        this.nc = 0;
      }
      if ((_ref16 = this.ncHex) == null) {
        this.ncHex = "00000000";
      }
    }

    SipTransaction.prototype.set = function(args) {
      var key, value, _results;
      _results = [];
      for (key in args) {
        value = args[key];
        _results.push(this[key] = value);
      }
      return _results;
    };

    SipTransaction.prototype.randomString = function(n, hex) {
      var array, character, limit, string, _i, _len;
      if (hex == null) {
        hex = false;
      }
      if (hex) {
        string = Math.random().toString(16).slice(2);
      } else {
        string = Math.random().toString(32).slice(2);
        string = string.concat(Math.random().toString(32).toUpperCase().slice(2));
      }
      array = _.shuffle(string.split(""));
      string = "";
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        character = array[_i];
        string += character;
      }
      limit = Math.min(string.length, n);
      string = string.slice(0, limit);
      while (string.length < n) {
        string += this.randomString(n - string.length, hex);
      }
      return string.slice(0, n);
    };

    SipTransaction.prototype.getUuid = function() {
      if (localStorage["uuid"] === null || localStorage["uuid"] === void 0) {
        localStorage["uuid"] = "" + (this.randomString(3, true)) + "-" + (this.randomString(4, true)) + "-" + (this.randomString(8, true));
      }
      this.uuid = localStorage["uuid"];
      this.getUuid = function() {
        return this.uuid;
      };
      return this.uuid;
    };

    SipTransaction.prototype.randomIP = function() {
      var array, i, _i;
      array = [];
      for (i = _i = 0; _i <= 3; i = ++_i) {
        array.push(_.random(1, 255));
      }
      return array.join('.');
    };

    SipTransaction.prototype.updateCnonceNcHex = function() {
      var hex;
      this.cnonce = this.randomString(8);
      this.nc += 1;
      hex = Number(this.nc).toString(16);
      this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
      if (this.nc === 4294967296) {
        this.nc = 1;
        return this.ncHex = "00000001";
      }
    };

    return SipTransaction;

  })();

  window.SipTransaction = SipTransaction;

  SipStack = (function(_super) {

    __extends(SipStack, _super);

    SipStack.prototype.addTransaction = function(transaction) {
      return this._transactions[transaction.branch] = transaction;
    };

    SipStack.prototype.getTransaction = function(message) {
      return this._transactions[message.branch];
    };

    SipStack.prototype.getTransactions = function(filter) {
      return _.where(this._transactions, filter);
    };

    SipStack.prototype.deleteTransaction = function(message) {
      return this._transactions = _.omit(this._transactions, message.branch);
    };

    SipStack.prototype.checkDialog = function(transaction) {
      var _this = this;
      return !_.isEmpty(_.find(this._transactions, function(tr) {
        var check;
        return check = tr.callId === transaction.callId;
      }));
    };

    SipStack.prototype.info = function(message, data) {
      console.log("[INFO]    " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.warning = function(message, data) {
      console.warn("[WARNING] " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.error = function(message, data) {
      console.error("[ERROR]   " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.states = ["OFFLINE", "REGISTERING (before challenge)", "REGISTERING (after challenge)", "REGISTERED", "INCOMING CALL", "CALLING", "RINGING", "CALL STABLISHED (caller)", "CALL STABLISHED (callee)", "HANGING", "CANCELLING", "UNREGISTERING"];

    SipStack.prototype.responsePhrases = {
      100: "Trying",
      180: "Ringing",
      200: "OK",
      202: "Accepted",
      400: "Bad Request",
      401: "Unauthorized",
      403: "Forbidden",
      404: "Not Found (User not found)",
      407: "Proxy Authentication Required",
      408: "Request Time Out",
      481: "Call/Transaction Does Not Exists",
      486: "Busy Here",
      488: "Not acceptable here",
      500: "Server Internal Error",
      503: "Service Unavaliable"
    };

    SipStack.prototype.createRTC = function() {
      var _this = this;
      this.rtc = new RTC({
        mediaElements: this.mediaElements,
        mediaConstraints: this.mediaConstraints,
        turnServer: this.turnServer,
        stunServer: this.stunServer
      });
      this.rtc.bind("localstream", function(localstream) {
        return _this.trigger("localstream", {
          stream: localstream
        });
      });
      this.rtc.bind("localstream-screen", function(localstreamScreen) {
        return _this.trigger("localstream-screen", {
          stream: localstreamScreen
        });
      });
      this.rtc.bind("remotestream", function(remotestream) {
        return _this.trigger("remotestream", {
          callid: _this.currentCall.callId,
          stream: remotestream,
          uid: "-"
        });
      });
      this.rtc.bind("remotestream-screen", function(remotestreamScreen) {
        return _this.trigger("remotestream-screen", {
          callid: _this.currentCall.callId,
          stream: remotestreamScreen,
          uid: "-"
        });
      });
      return this.rtc;
    };

    function SipStack() {
      this.setState = __bind(this.setState, this);

      this.sendInstantMessage = __bind(this.sendInstantMessage, this);

      this.sendWithSDP = __bind(this.sendWithSDP, this);

      this.send = __bind(this.send, this);

      this.hangup = __bind(this.hangup, this);

      this.answer = __bind(this.answer, this);

      this.call = __bind(this.call, this);

      this.register = __bind(this.register, this);

      this.createMessage = __bind(this.createMessage, this);

      this.getDigest = __bind(this.getDigest, this);

      this.start = __bind(this.start, this);

      this.createRTC = __bind(this.createRTC, this);

      this.error = __bind(this.error, this);

      this.warning = __bind(this.warning, this);

      this.info = __bind(this.info, this);

      this.checkDialog = __bind(this.checkDialog, this);

      this.deleteTransaction = __bind(this.deleteTransaction, this);

      this.getTransactions = __bind(this.getTransactions, this);

      this.getTransaction = __bind(this.getTransaction, this);

      this.addTransaction = __bind(this.addTransaction, this);

      var _ref, _ref1, _ref2, _ref3, _ref4;
      SipStack.__super__.constructor.apply(this, arguments);
      this.sipServer = this.server.ip;
      this.port = this.server.port;
      this.path = this.server.path || "";
      this.transport = this.server.transport || "ws";
      this._transactions = {};
      this._instantMessages = {};
      this.setState(0);
      if ((_ref = this.hackViaTCP) == null) {
        this.hackViaTCP = false;
      }
      if ((_ref1 = this.hackIpContact) == null) {
        this.hackIpContact = false;
      }
      if ((_ref2 = this.hackno_Route_ACK_BYE) == null) {
        this.hackno_Route_ACK_BYE = false;
      }
      if ((_ref3 = this.hackContact_ACK_MESSAGES) == null) {
        this.hackContact_ACK_MESSAGES = false;
      }
      if ((_ref4 = this.hackUserPhone) == null) {
        this.hackUserPhone = false;
      }
      console.log("Creating QS with @hackViaTCP= " + this.hackViaTCP + " @hackIpContact=" + this.hackIpContact + " @hackno_Route_ACK_BYE=" + this.hackno_Route_ACK_BYE + " @hackContact_ACK_MESSAGES=" + this.hackContact_ACK_MESSAGES + " @hackUserPhone=" + this.hackUserPhone);
    }

    SipStack.prototype.start = function() {
      var _this = this;
      console.log("" + this.transport + "://" + this.sipServer + ":" + this.port + this.path);
      try {
        this.websocket = new WebSocket("" + this.transport + "://" + this.sipServer + ":" + this.port + this.path, "sip");
      } catch (e) {
        throw "" + this.transport + "://" + this.sipServer + ":" + this.port + this.path + " not open";
      }
      this.websocket.onerror = function(e) {
        console.error("Websocket failed.");
        return console.log(e.data);
      };
      this.info("websocket created");
      this.websocket.onopen = function(evt) {
        _this.info("websocket opened");
        return _this.onopen();
      };
      this.websocket.onmessage = function(evt) {
        var ack, busy, instantMessage, message, ok, register, ringing, transaction, unregister, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        message = Parser.parse(evt.data);
        _this.info("Input message", message);
        if ((11 > (_ref = _this.state) && _ref > 2) && (message.cseq.meth === "REGISTER")) {
          if (!_this.getTransaction(message)) {
            return;
          }
          switch (message.responseCode) {
            case 200:
              _this.info("RE-REGISTER answer", message);
              return;
            case 401:
            case 407:
              register = _this.getTransaction(message);
              register.vias = message.vias;
              register.cseq.number += 1;
              _.extend(register, _.pick(message, "realm", "nonce", "toTag"));
              register.auth = true;
              _this.send(_this.createMessage(register));
              return;
          }
        }
        if (_this.state > 2 && message.cseq.meth === "MESSAGE") {
          switch (message.meth) {
            case "MESSAGE":
              console.log("[MESSAGE] " + message.content);
              console.log(message);
              instantMessage = {
                from: message.from,
                to: message.ext2,
                content: message.content
              };
              _this.trigger("instant-message", instantMessage);
              _this.send(_this.createMessage(new SipTransaction(_.extend(message, {
                meth: "OK"
              }))));
              break;
            case "OK":
              console.log("[MESSAGE] OK");
              _this.deleteTransaction(message);
              break;
            default:
              if ((_ref1 = message.responseCode) !== 401 && _ref1 !== 407) {
                return;
              }
              if (!_this.getTransaction(message)) {
                return;
              }
              instantMessage = _this.getTransaction(message);
              _.extend(instantMessage, _.pick(message, "realm", "nonce", "toTag"));
              instantMessage.proxyAuth = message.responseCode === 407;
              instantMessage.auth = message.responseCode === 401;
              _this.send(_this.createMessage(instantMessage));
          }
          return;
        }
        if ((3 < (_ref2 = _this.state) && _ref2 < 9)) {
          if (message.meth === "INVITE") {
            _this.info("another-incoming-call", message);
            busy = _.clone(message);
            _.extend(busy, {
              meth: "Busy here"
            });
            _this.send(_this.createMessage(busy));
            return;
          }
        }
        switch (_this.state) {
          case 1:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            transaction.vias = message.vias;
            switch (message.responseCode) {
              case 200:
                _this.info("register-success", message);
                _this.setState(3, message);
                transaction.expires = message.proposedExpires || 3600;
                _this.reRegister = function() {
                  var newRegister;
                  newRegister = _this.getTransaction(transaction);
                  newRegister.cseq.number += 1;
                  return _this.send(_this.createMessage(newRegister));
                };
                _this.t = setInterval(_this.reRegister, transaction.expires * 1000);
                _this.unregister = function() {
                  clearInterval(_this.t);
                  if (_this.currentCall) {
                    _this.hangup(_this.currentCall.callId);
                  }
                  console.log("[INFO] unregistering");
                  transaction = _this.getTransaction(message);
                  transaction.expires = 0;
                  message = _this.createMessage(transaction);
                  _this.send(message);
                  return _this.setState(11, message);
                };
                return _this.gruu = message.gruu;
              case 401:
              case 407:
                _this.setState(2, message);
                transaction.cseq.number += 1;
                transaction = _.extend(transaction, _.pick(message, "realm", "nonce", "toTag", "qop", "opaque"));
                transaction.auth = true;
                if (transaction.qop === "auth") {
                  transaction.updateCnonceNcHex();
                }
                return _this.send(_this.createMessage(transaction));
              default:
                return _this.warning("Unexpected answer for REGISTER: " + message.responseCode, message);
            }
            break;
          case 2:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            transaction.vias = message.vias;
            switch (message.responseCode) {
              case 200:
                _this.info("register-success", message);
                _this.setState(3, message);
                transaction.expires = message.proposedExpires;
                _this.reRegister = function() {
                  var newRegister;
                  newRegister = _this.getTransaction(transaction);
                  newRegister.cseq.number += 1;
                  return _this.send(_this.createMessage(newRegister));
                };
                _this.t = setInterval(_this.reRegister, transaction.expires * 1000);
                _this.unregister = function() {
                  clearInterval(_this.t);
                  if (_this.currentCall) {
                    _this.hangup(_this.currentCall.callId);
                  }
                  console.log("[INFO] unregistering");
                  transaction = _this.getTransaction(message);
                  transaction.expires = 0;
                  message = _this.createMessage(transaction);
                  _this.send(message);
                  return _this.setState(11, message);
                };
                return _this.gruu = message.gruu;
              case 401:
                _this.info("register-fail", message);
                return _this.setState(0, message);
              default:
                _this.warning("message-unexpected", message);
                return _this.setState(0, message);
            }
            break;
          case 3:
            switch (message.meth) {
              case "INVITE":
                transaction = new SipTransaction(message);
                _this.addTransaction(transaction);
                ringing = _.clone(transaction);
                ringing.meth = "Ringing";
                _this.send(_this.createMessage(ringing));
                return _this.setState(6, message);
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 4:
            if (!_this.checkDialog(message)) {
              return;
            }
            switch (message.meth) {
              case "CANCEL":
                _this.info("Call ended");
                return _this.setState(3, message);
              case "ACK":
                return _this.setState(8, message);
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 5:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            _this.currentCall = message;
            switch (message.type) {
              case "response":
                if (_this.responsePhrases[message.responseCode]) {
                  _this.info(_this.responsePhrases[message.responseCode], message);
                } else {
                  _this.warning("Unexpected response", message);
                  return;
                }
                switch (message.responseCode) {
                  case 180:
                    return transaction.contact = message.contact;
                  case 200:
                    _this.info("Establishing call", message);
                    _this.rtc.receiveAnswer(message.content);
                    _.extend(transaction, _.pick(message, "from", "to", "fromTag", "toTag"));
                    ack = new SipTransaction(message);
                    ack.meth = "ACK";
                    _this.send(_this.createMessage(ack));
                    return _this.setState(7, message);
                  case 401:
                  case 407:
                    if (message.responseCode === 401) {
                      _this.info("AUTH", message);
                    }
                    if (message.responseCode === 407) {
                      _this.info("PROXY-AUTH", message);
                    }
                    ack = new SipTransaction(_.omit(message, "nonce"));
                    ack.meth = "ACK";
                    ack.vias = message.vias;
                    _this.send(_this.createMessage(ack));
                    transaction.vias = message.vias;
                    transaction.cseq.number += 1;
                    _.extend(transaction, _.pick(message, "realm", "nonce", "toTag"));
                    transaction.auth = message.responseCode === 401;
                    transaction.proxyAuth = message.responseCode === 407;
                    console.log(transaction);
                    message = _this.createMessage(transaction);
                    return _this.sendWithSDP(message, "offer", null);
                  default:
                    if (400 <= message.responseCode) {
                      ack = new SipTransaction(_.omit(message, "nonce"));
                      ack.meth = "ACK";
                      ack.vias = message.vias;
                      _this.send(_this.createMessage(ack));
                      _this.setState(3, message);
                      _this.deleteTransaction("INVITE");
                      return _this.currentCall = message;
                    }
                }
                break;
              case "request":
                switch (message.meth) {
                  case "BYE":
                    _this.info("Call ended", message);
                    ok = new SipTransaction(message);
                    ok.meth = "OK";
                    _this.send(_this.createMessage(ok));
                    _this.setState(3, message);
                    return _this.currentCall = message;
                  default:
                    return _this.warning("Unexpected message", message);
                }
            }
            break;
          case 6:
            if (!_this.checkDialog(message)) {
              return;
            }
            _this.currentCall = message;
            _this.info("RINGING", message);
            switch (message.meth) {
              case "CANCEL":
                _this.info("Call ended", message);
                ok = new SipTransaction(message);
                ok.meth = "OK";
                _this.send(_this.createMessage(ok));
                return _this.setState(3, message);
            }
            break;
          case 7:
          case 8:
            if (!_this.checkDialog(message)) {
              return;
            }
            _this.info("CALL ESTABLISHED", message);
            switch (message.meth) {
              case "BYE":
                _this.info("Call finished", message);
                transaction = new SipTransaction(message);
                transaction.vias = message.vias;
                transaction.meth = "OK";
                ok = _.clone(transaction);
                _this.send(_this.createMessage(ok));
                _this.rtc.close();
                return _this.setState(3, message);
            }
            break;
          case 9:
            if (!_this.getTransaction(message)) {
              return;
            }
            _this.info("HANGING UP", message);
            _this.info("Call ended", message);
            if ((_ref3 = _this.rtc) != null) {
              _ref3.close();
            }
            _this.setState(3, message);
            return _this.currentCall = null;
          case 10:
            if (!_this.getTransaction(message)) {
              return;
            }
            _this.info("HANGING UP", message);
            _this.info("Call ended", message);
            if ((_ref4 = _this.rtc) != null) {
              _ref4.close();
            }
            _this.setState(3, message);
            return _this.currentCall = null;
          case 11:
            if (!_this.getTransaction(message)) {
              return;
            }
            switch (message.responseCode) {
              case 200:
                _this.info("unregister-success", message);
                return _this.setState(0);
              case 401:
              case 407:
                if ((_ref5 = message.responseCode) !== 401 && _ref5 !== 407) {
                  return;
                }
                unregister = _this.getTransaction(message);
                _.extend(unregister, _.pick(message, "realm", "nonce", "toTag"));
                unregister.proxyAuth = message.responseCode === 407;
                unregister.auth = message.responseCode === 401;
                _this.send(_this.createMessage(unregister));
                _this.info("unregister-success", message);
                return _this.setState(0);
            }
        }
      };
      return this.websocket.onclose = function(evt) {
        return _this.info("websocket closed");
      };
    };

    SipStack.prototype.getDigest = function(transaction) {
      var ha1, ha2, sol;
      if (transaction.qop === "auth") {
        ha1 = CryptoJS.MD5("" + transaction.userAuthName + ":" + transaction.realm + ":" + transaction.pass);
        console.log("HA1 = md5(" + transaction.userAuthName + ":" + transaction.realm + ":" + transaction.pass + ")");
      } else {
        ha1 = CryptoJS.MD5("" + transaction.userAuthName + ":" + transaction.realm + ":" + transaction.pass);
        console.log("HA1 = md5(" + transaction.userAuthName + ":" + transaction.realm + ":" + transaction.pass + ")");
      }
      console.log("HA1 = " + ha1);
      ha2 = CryptoJS.MD5("" + transaction.meth + ":" + transaction.requestUri);
      console.log("HA2 = md5(" + transaction.meth + ":" + transaction.requestUri + ")");
      console.log("HA2 = " + ha2);
      if (transaction.qop === "auth") {
        sol = CryptoJS.MD5("" + ha1 + ":" + transaction.nonce + ":" + transaction.ncHex + ":" + transaction.cnonce + ":auth:" + ha2);
        console.log("response = md5(" + ha1 + ":" + transaction.nonce + ":" + transaction.ncHex + ":" + transaction.cnonce + ":auth:" + ha2 + ")");
      } else {
        sol = CryptoJS.MD5("" + ha1 + ":" + transaction.nonce + ":" + ha2);
        console.log("response = md5(" + ha1 + ":" + transaction.nonce + ":" + ha2 + ")");
      }
      console.log("response = " + sol);
      return sol;
    };

    SipStack.prototype.createMessage = function(transaction) {
      var address, authUri, data, length, opaque, qop, rr, _i, _len, _ref;
      transaction = new SipTransaction(transaction);
      transaction.uri = "sip:" + transaction.ext + "@" + (this.domain || this.sipServer);
      transaction.uri2 = "sip:" + transaction.ext2 + "@" + (transaction.domain2 || this.sipServer);
      transaction.targetUri = "sip:" + (this.domain || this.sipServer);
      if (transaction.meth === "BYE") {
        transaction.cseq.number += 1;
      }
      transaction.ltFrom = "";
      transaction.gtFrom = "";
      transaction.ltTo = "";
      transaction.gtTo = "";
      if (this.hackUserPhone) {
        transaction.ltFrom = "<";
        transaction.gtFrom = ">";
        transaction.ltTo = "<";
        transaction.gtTo = ">";
        transaction.UserPhone = ";user=phone";
      } else {
        transaction.UserPhone = "";
      }
      switch (transaction.meth) {
        case "REGISTER":
          transaction.requestUri = transaction.targetUri;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "INVITE":
        case "MESSAGE":
        case "CANCEL":
          transaction.requestUri = transaction.uri2;
          data = "" + transaction.meth + " " + transaction.requestUri + transaction.UserPhone + " SIP/2.0\r\n";
          break;
        case "BYE":
          transaction.requestUri = transaction.contact || transaction.uri2 + transaction.UserPhone;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "ACK":
          transaction.requestUri = transaction.contact || transaction.uri2;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "OK":
          data = "SIP/2.0 200 OK\r\n";
          break;
        case "Ringing":
          data = "SIP/2.0 180 Ringing\r\n";
          break;
        case "Busy here":
          data = "SIP/2.0 486 Busy Here\r\n";
      }
      if ((transaction.cseq.meth === "INVITE" && transaction.meth !== "ACK") && (_.isArray(transaction.recordRoutes))) {
        _ref = transaction.recordRoutes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rr = _ref[_i];
          data += rr + "\r\n";
        }
      } else {
        switch (transaction.meth) {
          case "REGISTER":
          case "INVITE":
          case "MESSAGE":
          case "CANCEL":
            data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr>\r\n";
            break;
          case "OK":
            if (transaction.cseq.meth !== "MESSAGE") {
              data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr=on>\r\n";
            }
            break;
          case "BYE":
          case "ACK":
            if (!this.hackno_Route_ACK_BYE) {
              if (transaction.cseq.meth !== "MESSAGE") {
                data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr=on>\r\n";
              }
            }
        }
      }
      if (_.isArray(transaction.vias)) {
        data += (transaction.vias.join("\r\n")) + "\r\n";
      } else {
        data += "Via: SIP/2.0/" + ((this.hackViaTCP && "TCP") || this.transport.toUpperCase()) + " " + transaction.domainName + ";branch=" + transaction.branch + "\r\n";
      }
      switch (transaction.meth) {
        case "Ringing":
        case "OK":
        case "BYE":
        case "ACK":
          data += "From: <" + transaction.from + ">" + transaction.fromTag + " \r\n";
          break;
        default:
          data += "From: " + transaction.ltFrom + transaction.uri + transaction.UserPhone + transaction.gtFrom + transaction.fromTag + "\r\n";
      }
      switch (transaction.meth) {
        case "REGISTER":
          data += "To: " + transaction.ltTo + transaction.uri + transaction.UserPhone + transaction.gtTo + "\r\n";
          break;
        case "INVITE":
        case "MESSAGE":
        case "CANCEL":
          data += "To:  " + transaction.ltTo + transaction.uri2 + transaction.UserPhone + transaction.gtTo + "\r\n";
          break;
        case "Ringing":
        case "OK":
        case "BYE":
        case "ACK":
          data += "To: <" + transaction.to + ">" + transaction.toTag + "\r\n";
          break;
        default:
          data += "To: " + transaction.ltTo + transaction.uri2 + transaction.UserPhone + transaction.gtTo + transaction.toTag + "\r\n";
      }
      data += "Call-ID: " + transaction.callId + "\r\n";
      switch (transaction.meth) {
        case "OK":
          data += "CSeq: " + transaction.cseq.number + " " + (transaction.cseq.meth || transaction.meth) + "\r\n";
          break;
        case "Ringing":
          data += "CSeq: " + transaction.cseq.number + " " + transaction.cseq.meth + "\r\n";
          break;
        case "ACK":
          data += "CSeq: " + transaction.cseq.number + " ACK\r\n";
          break;
        case "Busy here":
          data += "CSeq: " + transaction.cseq.number + " INVITE\r\n";
          break;
        default:
          data += "CSeq: " + transaction.cseq.number + " " + transaction.meth + "\r\n";
      }
      data += "Max-Forwards: 70\r\n";
      if (transaction.meth === "REGISTER" || transaction.meth === "INVITE") {
        data += "Allow: INVITE, ACK, CANCEL, BYE, MESSAGE\r\n";
      }
      data += "Supported: path, gruu\r\n";
      data += "User-Agent: QoffeeSIP 0.7\r\n";
      address = (this.hackIpContact && transaction.IP) || transaction.domainName;
      switch (transaction.meth) {
        case "Ringing":
          if (this.gruu) {
            data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";gr=urn:uuid:" + transaction.uuid + ">\r\n";
          } else {
            data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";transport=ws>\r\n";
          }
          break;
        case "OK":
          if (transaction.cseq.meth === "INVITE") {
            if (this.gruu) {
              data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";gr=urn:uuid:" + transaction.uuid + ">\r\n";
            } else {
              data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";transport=ws>\r\n";
            }
          }
          break;
        case "REGISTER":
          data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws>";
          break;
        case "INVITE":
          if (this.gruu) {
            data += "Contact: <" + this.gruu + ";ob>\r\n";
          } else {
            data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws;ob>\r\n";
          }
          break;
        case "ACK":
        case "MESSAGE":
          if (this.hackContact_ACK_MESSAGES) {
            if (this.gruu) {
              data += "Contact: <" + this.gruu + ";ob>\r\n";
            } else {
              data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws;ob>\r\n";
            }
          }
      }
      switch (transaction.meth) {
        case "REGISTER":
          data += ";reg-id=" + transaction.regid;
          data += ";+sip.instance=\"<urn:uuid:" + transaction.uuid + ">\"";
          if (transaction.expires != null) {
            data += ";expires=" + transaction.expires;
          }
          data += "\r\n";
      }
      if (transaction.nonce != null) {
        opaque = "";
        if (transaction.opaque != null) {
          opaque = ",opaque=\"" + transaction.opaque + "\"";
        }
        qop = "";
        if (transaction.qop != null) {
          qop = ",qop=" + transaction.qop + ",cnonce=\"" + transaction.cnonce + "\",nc=" + transaction.ncHex;
        }
        if (transaction.auth === true) {
          if (transaction.cseq.meth === "REGISTER") {
            authUri = transaction.targetUri;
          } else {
            authUri = transaction.uri2;
          }
          data += "Authorization:";
        }
        if (transaction.proxyAuth === true) {
          authUri = transaction.uri2;
          data += "Proxy-Authorization:";
        }
        transaction.response = this.getDigest(transaction);
        data += " Digest username=\"" + transaction.userAuthName + "\",realm=\"" + transaction.realm + "\",";
        data += "nonce=\"" + transaction.nonce + "\"" + opaque + ",uri=\"" + authUri + "\",response=\"" + transaction.response + "\",algorithm=MD5" + qop + "\r\n";
      }
      switch (transaction.meth) {
        case "INVITE":
        case "OK":
          if (transaction.cseq.meth === "INVITE") {
            data += "Content-Type: application/sdp\r\n";
          } else {
            data += "Content-Length: 0\r\n\r\n";
          }
          break;
        case "MESSAGE":
          length = encodeURI(transaction.content).split(/%..|./).length - 1;
          data += "Content-Length: " + (length || 0) + "\r\n";
          data += "Content-Type: text/plain;charset=utf-8\r\n\r\n";
          data += transaction.content;
          break;
        default:
          data += "Content-Length: 0\r\n\r\n";
      }
      return data;
    };

    SipStack.prototype.register = function(uri, pass, userAuthName) {
      var message, transaction;
      this.pass = pass;
      this.userAuthName = userAuthName;
      transaction = new SipTransaction({
        meth: "REGISTER",
        uri: uri,
        pass: this.pass || "",
        userAuthName: this.userAuthName || ""
      });
      this.ext = transaction.ext;
      this.domain = transaction.domain || this.sipServer;
      this.addTransaction(transaction);
      this.setState(1, transaction);
      message = this.createMessage(transaction);
      return this.send(message);
    };

    SipStack.prototype.call = function(uri2) {
      var message, transaction,
        _this = this;
      transaction = new SipTransaction({
        meth: "INVITE",
        uri: this.ext,
        pass: this.pass,
        uri2: uri2,
        userAuthName: this.userAuthName
      });
      this.addTransaction(transaction);
      message = this.createMessage(transaction);
      return this.sendWithSDP(message, "offer", null, function() {
        return _this.setState(5, transaction);
      });
    };

    SipStack.prototype.answer = function(callId) {
      var ok,
        _this = this;
      console.log("Answer " + callId);
      this.currentCall = _.first(this.getTransactions({
        callId: callId
      }));
      ok = _.clone(this.currentCall);
      ok.meth = "OK";
      return this.sendWithSDP(this.createMessage(ok), "answer", this.currentCall.content, function() {
        return _this.setState(4, ok);
      });
    };

    SipStack.prototype.hangup = function(callId) {
      var busy, bye, cancel, invite, swap, _ref, _ref1, _ref2;
      if ((_ref = this.rtc) != null) {
        _ref.unbind("sdp");
      }
      swap = function(d, p1, p2) {
        var _ref1;
        return _ref1 = [d[p2], d[p1]], d[p1] = _ref1[0], d[p2] = _ref1[1], _ref1;
      };
      invite = _.first(this.getTransactions({
        callId: callId
      }));
      switch (this.state) {
        case 5:
          cancel = new SipTransaction({
            meth: "CANCEL",
            ext: this.ext,
            domain: this.domain,
            ext2: invite.ext2,
            domain2: invite.domain2
          });
          _.extend(cancel, _.pick(invite, "callId", "fromTag", "from", "to", "cseq", "domainName", "branch"));
          this.send(this.createMessage(cancel));
          this.setState(10);
          break;
        case 6:
          busy = new SipTransaction({
            meth: "Busy here",
            ext: this.ext,
            ext2: invite.ext
          });
          _.extend(busy, _.pick(invite, "callId", "fromTag", "from", "to", "cseq", "domainName", "branch", "vias"));
          this.send(this.createMessage(busy));
          this.setState(9, busy);
          break;
        case 7:
          bye = new SipTransaction({
            meth: "BYE",
            ext: this.ext,
            ext2: invite.ext2
          });
          _.extend(bye, _.pick(invite, "callId", "contact", "fromTag", "toTag", "from", "to", "cseq"));
          this.send(this.createMessage(bye));
          this.addTransaction(bye);
          this.setState(9, bye);
          if ((_ref1 = this.rtc) != null) {
            _ref1.close();
          }
          break;
        case 8:
          bye = new SipTransaction({
            meth: "BYE",
            ext: this.ext,
            ext2: invite.ext
          });
          _.extend(bye, _.pick(invite, "callId", "contact", "fromTag", "toTag", "from", "to", "cseq", "vias"));
          swap(bye, "fromTag", "toTag");
          swap(bye, "from", "to");
          this.send(this.createMessage(bye));
          this.addTransaction(bye);
          this.setState(9, bye);
          if ((_ref2 = this.rtc) != null) {
            _ref2.close();
          }
      }
      return this.currentCall = null;
    };

    SipStack.prototype.send = function(data) {
      if (data != null) {
        console.log("[INFO] Sending data", data);
        try {
          return this.websocket.send(data);
        } catch (e) {
          return this.error("websocket", e);
        }
      } else {
        return console.log("[INFO] Not sending data");
      }
    };

    SipStack.prototype.sendWithSDP = function(data, type, sdp, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      this.createRTC();
      this.rtc.bind("sdp", function(sdp) {
        var _ref;
        data += "Content-Length: " + sdp.length + "\r\n\r\n";
        data += sdp;
        _this.send(data);
        if ((_ref = _this.rtc) != null) {
          _ref.unbind("sdp");
        }
        return cb();
      });
      switch (type) {
        case "offer":
          return this.rtc.createOffer();
        case "answer":
          return this.rtc.receiveOffer(sdp, function() {
            return _this.rtc.createAnswer();
          });
      }
    };

    SipStack.prototype.sendInstantMessage = function(uri2, text) {
      var message;
      message = new SipTransaction({
        meth: "MESSAGE",
        ext: this.ext,
        pass: this.pass,
        uri2: uri2,
        content: text
      });
      this.addTransaction(message);
      return this.send(this.createMessage(message));
    };

    SipStack.prototype.setState = function(state, data) {
      this.state = state;
      console.log("[INFO] New state  " + this.states[this.state] + ("(" + this.state + ")"));
      return this.trigger("new-state", this.state, data);
    };

    return SipStack;

  })(Spine.Controller);

  window.SipStack = SipStack;

  QS = (function(_super) {

    __extends(QS, _super);

    function QS(options) {
      this.insertDTMF = __bind(this.insertDTMF, this);

      this.attachStream = __bind(this.attachStream, this);

      this.mediaState = __bind(this.mediaState, this);

      this.unmuteAudio = __bind(this.unmuteAudio, this);

      this.muteAudio = __bind(this.muteAudio, this);

      this.unmuteVideo = __bind(this.unmuteVideo, this);

      this.muteVideo = __bind(this.muteVideo, this);

      this.toggleMuteAudio = __bind(this.toggleMuteAudio, this);

      this.toggleMuteVideo = __bind(this.toggleMuteVideo, this);

      this.off = __bind(this.off, this);

      this.on = __bind(this.on, this);

      this.cbUnregisterSuccess = __bind(this.cbUnregisterSuccess, this);

      this.cbRegisterSuccess = __bind(this.cbRegisterSuccess, this);

      this.cbRegisterFail = __bind(this.cbRegisterFail, this);

      this.cbAnotherIncomingCall = __bind(this.cbAnotherIncomingCall, this);

      this.cbRemotestreamScreen = __bind(this.cbRemotestreamScreen, this);

      this.cbRemotestream = __bind(this.cbRemotestream, this);

      this.cbLocalstreamScreen = __bind(this.cbLocalstreamScreen, this);

      this.cbLocalstream = __bind(this.cbLocalstream, this);

      this.chat = __bind(this.chat, this);

      this.updateMediaState = __bind(this.updateMediaState, this);

      this.updatePresenceState = __bind(this.updatePresenceState, this);

      this.unregister = __bind(this.unregister, this);

      this.hangup = __bind(this.hangup, this);

      this.answer = __bind(this.answer, this);

      this.call = __bind(this.call, this);

      this.capabilities = __bind(this.capabilities, this);

      this.register = __bind(this.register, this);

      this.cbStateChange = __bind(this.cbStateChange, this);

      this.cbInstantMessage = __bind(this.cbInstantMessage, this);

      this.onopen = __bind(this.onopen, this);

      this.start = __bind(this.start, this);
      QS.__super__.constructor.apply(this, arguments);
      this.lastState = "";
      this.stateflow = [];
      this.mappedEvents = ['qs-instant-message', 'qs-localstream', 'qs-localstream-screen', 'qs-remotestream', 'qs-remotestream-screen', 'qs-register-error', 'qs-register-success', 'qs-unregister-success', 'qs-another-incoming-call'];
      this.customEvents = {
        'qs-ringing': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-calling': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-end-call': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-lost-call': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-established': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-instant-message': {
          stack: 'instant-message',
          cb: this.cbInstantMessage
        },
        'qs-presence-update': {
          stack: 'instant-message',
          cb: this.cbInstantMessage
        },
        'qs-mediastate-update': {
          stack: 'instant-message',
          cb: this.cbInstantMessage
        }
      };
      this.customEventsReverse = {
        'new-state': {
          counter: 0
        },
        'instant-message': {
          counter: 0
        }
      };
      this.libEvents = {
        'qs-localstream': {
          stack: 'localstream',
          cb: this.cbLocalstream
        },
        'qs-localstream-screen': {
          stack: 'localstream-screen',
          cb: this.cbLocalstreamScreen
        },
        'qs-remotestream': {
          stack: 'remotestream',
          cb: this.cbRemotestream
        },
        'qs-remotestream-screen': {
          stack: 'remotestream-screen',
          cb: this.cbRemotestreamScreen
        },
        'qs-register-error': {
          stack: 'register-fail',
          cb: this.cbRegisterFail
        },
        'qs-register-success': {
          stack: 'register-success',
          cb: this.cbRegisterSuccess
        },
        'qs-unregister-success': {
          stack: 'unregister-success',
          cb: this.cbUnregisterSuccess
        },
        'qs-another-incoming-call': {
          stack: "another-incoming-call",
          cb: this.cbAnotherIncomingCall
        }
      };
      this.sipStack = new SipStack({
        server: this.server,
        iceServer: this.iceServer,
        hackViaTCP: this.hackViaTCP,
        hackIpContact: this.hackIpContact,
        hackno_Route_ACK_BYE: this.hackno_Route_ACK_BYE,
        hackContact_ACK_MESSAGES: this.hackContact_ACK_MESSAGES,
        hackUserPhone: this.hackUserPhone,
        mediaConstraints: this.mediaConstraints,
        onopen: this.onopen
      });
    }

    QS.prototype.start = function() {
      return this.sipStack.start();
    };

    QS.prototype.onopen = function() {
      return this.trigger("qs-ready");
    };

    QS.prototype.cbInstantMessage = function(data) {
      var chattext, header, lines;
      lines = data.content.split(/\n/);
      header = JSON.parse(lines[0]);
      chattext = lines[1];
      if (header.hasOwnProperty("presenceState")) {
        this.trigger('qs-presence-update', {
          userid: data.from,
          state: header.presenceState,
          answerme: header.answerme
        });
      }
      if (header.hasOwnProperty("mediaState")) {
        this.trigger('qs-mediastate-update', {
          userid: data.from,
          video: header.mediaState.video
        });
      }
      if (chattext.length) {
        return this.trigger('qs-instant-message', {
          userid: data.from,
          text: chattext
        });
      }
    };

    QS.prototype.cbStateChange = function(state, message) {
      this.state = state;
      console.warn(this.stateflow);
      switch (this.state) {
        case 3:
          if (_.isEqual(this.stateflow, [5, 78, 9])) {
            console.warn("outgoing call, answered, caller hangs up");
            this.trigger('qs-end-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [5, 78])) {
            console.warn("outgoing call, answered, callee hangs up");
            this.trigger('qs-end-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [6, 78])) {
            console.warn("incoming call, answered, caller hangs up");
            this.trigger('qs-end-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [6, 78, 9])) {
            console.warn("incoming call, answered, callee hangs up");
            this.trigger('qs-end-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [5, 10])) {
            console.warn("outgoing call, not answered, hangup by caller or callee");
            this.trigger('qs-lost-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [5])) {
            console.warn("outgoing call, not answered, hangup by callee");
            this.trigger('qs-lost-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [6])) {
            console.warn("incoming call, not answered, hang it up by caller");
            this.trigger('qs-lost-call', {
              callid: message.callId
            });
          } else if (_.isEqual(this.stateflow, [6, 9])) {
            console.warn("incoming call, not answered, hang it up by callee");
            this.trigger('qs-lost-call', {
              callid: message.callId
            });
          }
          return this.stateflow = [];
        case 5:
          this.stateflow.push(5);
          return this.trigger('qs-calling', {
            userid: message.ext2,
            callid: message.callId
          });
        case 6:
          this.stateflow.push(6);
          return this.trigger('qs-ringing', {
            userid: message.ext,
            callid: message.callId
          });
        case 7:
        case 8:
          this.stateflow.push(78);
          return this.trigger('qs-established', {
            callid: message.callId
          });
        case 9:
          return this.stateflow.push(9);
        case 10:
          return this.stateflow.push(10);
      }
    };

    QS.prototype.register = function(uri, pass, userAuthName) {
      if (pass == null) {
        pass = "";
      }
      return this.sipStack.register(uri, pass, userAuthName);
    };

    QS.prototype.capabilities = function() {
      return ['audio', 'video', 'chat', 'presence'];
    };

    QS.prototype.version = function() {
      return [
        {
          name: "QoffeeSIP",
          version: "v0.8.0"
        }
      ];
    };

    QS.prototype.call = function(uri2) {
      return this.sipStack.call(uri2);
    };

    QS.prototype.answer = function(callid) {
      return this.sipStack.answer(callid);
    };

    QS.prototype.hangup = function(callid) {
      return this.sipStack.hangup(callid);
    };

    QS.prototype.unregister = function() {
      return this.sipStack.unregister();
    };

    QS.prototype.updatePresenceState = function(uri2, state, answerme) {
      var content;
      if (answerme == null) {
        answerme = false;
      }
      this.lastState = state;
      content = JSON.stringify({
        presenceState: state,
        answerme: Boolean(answerme)
      }) + "\n";
      return this.sipStack.sendInstantMessage(uri2, content);
    };

    QS.prototype.updateMediaState = function(uri2) {
      var content;
      content = JSON.stringify({
        presenceState: this.sipStack.rtc.mediaState()
      }) + "\n";
      return this.sipStack.sendInstantMessage(uri2, content);
    };

    QS.prototype.chat = function(uri2, text) {
      var content;
      content = JSON.stringify({
        presenceState: this.lastState
      }) + "\n" + text;
      return this.sipStack.sendInstantMessage(uri2, content);
    };

    QS.prototype.cbLocalstream = function(evt) {
      return this.trigger("qs-localstream", evt);
    };

    QS.prototype.cbLocalstreamScreen = function(evt) {
      return this.trigger("qs-localstream-screen", evt);
    };

    QS.prototype.cbRemotestream = function(evt) {
      return this.trigger("qs-remotestream", evt);
    };

    QS.prototype.cbRemotestreamScreen = function(evt) {
      return this.trigger("qs-remotestream-screen", evt);
    };

    QS.prototype.cbAnotherIncomingCall = function(data) {
      return this.trigger("qs-another-incoming-call", {
        userid: data.from
      });
    };

    QS.prototype.cbRegisterFail = function() {
      return this.trigger('qs-register-error');
    };

    QS.prototype.cbRegisterSuccess = function() {
      return this.trigger('qs-register-success');
    };

    QS.prototype.cbUnregisterSuccess = function() {
      return this.trigger('qs-unregister-success');
    };

    QS.prototype.on = function(eventName, callback) {
      if (this.customEvents[eventName] != null) {
        if (this.customEventsReverse[this.customEvents[eventName].stack].counter === 0) {
          this.customEventsReverse[this.customEvents[eventName].stack].counter += 1;
          this.sipStack.bind(this.customEvents[eventName].stack, this.customEvents[eventName].cb);
        }
      } else if (__indexOf.call(this.mappedEvents, eventName) >= 0) {
        this.sipStack.bind(this.libEvents[eventName].stack, this.libEvents[eventName].cb);
      }
      return this.bind(eventName, callback);
    };

    QS.prototype.off = function(eventName, callback) {
      var _ref;
      if (this.customEvents[eventName] != null) {
        if (this.customEventsReverse[this.customEvents[eventName].stack].counter !== 0) {
          this.customEventsReverse[this.customEvents[eventName].stack].counter -= 1;
          this.sipStack.unbind(this.customEvents[eventName].stack, this.customEvents[eventName].cb);
        }
      } else if (_ref = !eventName, __indexOf.call(this.mappedEvents, _ref) >= 0) {
        this.sipStack.unbind(this.libEvents[eventName].stack, this.libEvents[eventName].cb);
      }
      return this.unbind(eventName, callback);
    };

    QS.prototype.toggleMuteVideo = function() {
      return this.sipStack.rtc.toggleMuteVideo();
    };

    QS.prototype.toggleMuteAudio = function() {
      return this.sipStack.rtc.toggleMuteAudio();
    };

    QS.prototype.muteVideo = function() {
      return this.sipStack.rtc.muteVideo();
    };

    QS.prototype.unmuteVideo = function() {
      return this.sipStack.rtc.unmuteVideo();
    };

    QS.prototype.muteAudio = function() {
      return this.sipStack.rtc.muteAudio();
    };

    QS.prototype.unmuteAudio = function() {
      return this.sipStack.rtc.unmuteAudio();
    };

    QS.prototype.mediaState = function() {
      return this.sipStack.rtc.mediaState();
    };

    QS.prototype.attachStream = function($d, stream) {
      return this.sipStack.rtc.attachStream($d, stream);
    };

    QS.prototype.insertDTMF = function(callid, tone) {
      return this.sipStack.rtc.insertDTMF(tone);
    };

    return QS;

  })(Spine.Controller);

  window.QS = QS;

  window.Concretestack = QS;

}).call(this);
