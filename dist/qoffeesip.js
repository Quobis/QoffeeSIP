/*
@source: https://github.com/Quobis/QoffeeSIP
Copyright (C) Quobis
Licensed under GNU-LGPL-3.0-or-later (http://www.gnu.org/licenses/lgpl-3.0.html)
*/
// Generated by CoffeeScript 1.4.0
(function() {
  var Parser, QS, RTC, SipStack, SipTransaction,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  RTC = (function(_super) {

    __extends(RTC, _super);

    RTC.include(Spine.Events);

    function RTC(args) {
      this.insertDTMF = __bind(this.insertDTMF, this);

      this.mediaState = __bind(this.mediaState, this);

      this.toggleMuteVideo = __bind(this.toggleMuteVideo, this);

      this.unmuteVideo = __bind(this.unmuteVideo, this);

      this.muteVideo = __bind(this.muteVideo, this);

      this.unmuteAudio = __bind(this.unmuteAudio, this);

      this.muteAudio = __bind(this.muteAudio, this);

      this.toggleMuteAudio = __bind(this.toggleMuteAudio, this);

      this.close = __bind(this.close, this);

      this.receiveAnswer = __bind(this.receiveAnswer, this);

      this.receiveOffer = __bind(this.receiveOffer, this);

      this.receive = __bind(this.receive, this);

      this.createAnswer = __bind(this.createAnswer, this);

      this.createOffer = __bind(this.createOffer, this);

      this.setLocalDescription = __bind(this.setLocalDescription, this);

      this.triggerSDP = __bind(this.triggerSDP, this);

      this.createStream = __bind(this.createStream, this);

      this.createPeerConnection = __bind(this.createPeerConnection, this);

      this.start = __bind(this.start, this);

      this.browserSupport = __bind(this.browserSupport, this);

      var key, value, _ref;
      console.log("[INFO] RTC constructor");
      for (key in args) {
        value = args[key];
        this[key] = value;
      }
      if (this.mediaElements != null) {
        this.$dom1 = this.mediaElements.localMedia;
        this.$dom2 = this.mediaElements.remoteMedia;
        this.$dom1[0].volume = 0;
      } else {
        this.$dom1 = this.$dom2 = null;
      }
      if ((_ref = this.mediaConstraints) == null) {
        this.mediaConstraints = {
          audio: true,
          video: true
        };
      }
      this.browserSupport();
      this.iceServers = [];
      if (this.stunServer != null) {
        this.iceServers.push(this.stunServer);
      }
      if (this.turnServer != null) {
        this.iceServers.push(this.turnServer);
      }
      this.isVideoActive = true;
      this.isAudioActive = true;
    }

    RTC.prototype.browserSupport = function() {
      var _this = this;
      if (navigator.mozGetUserMedia) {
        this.browser = "firefox";
        this.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
        this.PeerConnection = mozRTCPeerConnection;
        this.RTCSessionDescription = mozRTCSessionDescription;
        this.attachStream = function($d, stream) {
          if (!$d) {
            return;
          }
          console.log("[INFO] attachStream");
          $d.attr('src', window.URL.createObjectURL(stream));
          return $d.get(0).play();
        };
        MediaStream.prototype.getVideoTracks = function() {
          return [];
        };
        MediaStream.prototype.getAudioTracks = function() {
          return [];
        };
      }
      if (navigator.webkitGetUserMedia) {
        this.browser = "chrome";
        this.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
        this.PeerConnection = webkitRTCPeerConnection;
        this.RTCSessionDescription = RTCSessionDescription;
        this.attachStream = function($d, stream) {
          var url;
          if (!($d != null)) {
            return;
          }
          console.log("[INFO] attachStream");
          url = webkitURL.createObjectURL(stream);
          return $d.attr('src', url);
        };
        if (!webkitMediaStream.prototype.getVideoTracks) {
          webkitMediaStream.prototype.getVideoTracks = function() {
            return this.videoTracks;
          };
        }
        if (!webkitMediaStream.prototype.getAudioTracks) {
          webkitMediaStream.prototype.getAudioTracks = function() {
            return this.audioTracks;
          };
        }
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
          webkitRTCPeerConnection.prototype.getLocalStreams = function() {
            return this.localStreams;
          };
          return webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
            return this.remoteStreams;
          };
        }
      }
    };

    RTC.prototype.start = function() {
      console.log("PeerConnection starting");
      this.noMoreCandidates = this.browser === "firefox";
      this.dtmfSender = null;
      return this.createPeerConnection();
    };

    RTC.prototype.createPeerConnection = function() {
      var _this = this;
      console.log("[INFO] createPeerConnection");
      console.log("[MEDIA] ICE servers");
      console.log(this.iceServers);
      this.pc = new this.PeerConnection({
        "iceServers": this.iceServers
      });
      this.pc.onaddstream = function(event) {
        console.log("[MEDIA] Stream added");
        _this.remotestream = event.stream;
        _this.dtmfSender = _this.pc.createDTMFSender(_this.localstream.getAudioTracks()[0]);
        _this.dtmfSender.ontonechange = function(dtmf) {
          console.log(dtmf);
          return console.log("[INFO] DTMF send - " + dtmf.tone);
        };
        window.test = _this.insertDTMF;
        _this.attachStream(_this.$dom2, _this.remotestream);
        return _this.trigger("remotestream", _this.remotestream);
      };
      this.pc.onicecandidate = function(evt, moreToFollow) {
        var candidate;
        console.log("[INFO] onicecandidate");
        console.log(_this.pc.iceState);
        if (evt.candidate) {
          console.log("[INFO] New ICE candidate:");
          candidate = {
            type: 'candidate',
            label: evt.candidate.sdpMLineIndex,
            id: evt.candidate.sdpMid,
            candidate: evt.candidate.candidate
          };
          return console.log("" + candidate.candidate);
        } else {
          console.log("[INFO] No more ice candidates");
          _this.noMoreCandidates = true;
          if (_this.pc.localDescription != null) {
            return _this.triggerSDP();
          }
        }
      };
      if (this.browser === "chrome") {
        this.pc.onicechange = function(event) {
          return console.log("[INFO] icestate changed -> " + _this.pc.iceState);
        };
        this.pc.onstatechange = function(event) {
          return console.log("[INFO] peerconnectionstate changed -> " + _this.pc.readyState);
        };
        this.pc.onopen = function() {
          return console.log("[MEDIA] peerconnection opened");
        };
        this.pc.onclose = function() {
          return console.log("[INFO] peerconnection closed");
        };
      }
      return this.createStream();
    };

    RTC.prototype.createStream = function() {
      var gumFail, gumSuccess,
        _this = this;
      console.log("[INFO] createStream");
      if (this.localstream != null) {
        console.log("[INFO] Using media previously got.");
        this.pc.addStream(this.localstream);
        return this.attachStream(this.$dom1, this.localstream);
      } else {
        gumSuccess = function(stream) {
          var _ref;
          _this.localstream = stream;
          console.log("[INFO] getUserMedia successed");
          _this.pc.addStream(_this.localstream);
          _this.attachStream(_this.$dom1, _this.localstream);
          _this.trigger("localstream", _this.localstream);
          console.log("localstream", _this.localstream);
          return _ref = [stream.getVideoTracks().length > 0, stream.getAudioTracks().length > 0], _this.isVideoActive = _ref[0], _this.isAudioActive = _ref[1], _ref;
        };
        gumFail = function(error) {
          console.error(error);
          console.error("GetUserMedia error");
          return _this.trigger("error", "getUserMedia");
        };
        return this.getUserMedia(this.mediaConstraints, gumSuccess, gumFail);
      }
    };

    RTC.prototype.triggerSDP = function() {
      var sdp;
      console.log("[MEDIA]");
      sdp = this.pc.localDescription.sdp;
      return this.trigger("sdp", sdp);
    };

    RTC.prototype.setLocalDescription = function(sessionDescription, callback) {
      var fail, success,
        _this = this;
      success = function() {
        console.log("[INFO] setLocalDescription successed");
        if (_this.noMoreCandidates) {
          return _this.triggerSDP();
        }
      };
      fail = function() {
        return _this.trigger("error", "setLocalDescription", sessionDescription);
      };
      return this.pc.setLocalDescription(sessionDescription, success, fail);
    };

    RTC.prototype.createOffer = function() {
      var error,
        _this = this;
      console.log("[INFO] createOffer");
      error = function(e) {
        return _this.trigger("error", "createOffer", e);
      };
      return this.pc.createOffer(this.setLocalDescription, error, {});
    };

    RTC.prototype.createAnswer = function() {
      var error,
        _this = this;
      console.log("[INFO] createAnswer");
      error = function(e) {
        return _this.trigger("error", "createAnswer", e);
      };
      return this.pc.createAnswer(this.setLocalDescription, error, {});
    };

    RTC.prototype.receive = function(sdp, type, callback) {
      var description, success,
        _this = this;
      success = function() {
        console.log("[INFO] Remote description setted.");
        console.log("[INFO] localDescription:");
        console.log(_this.pc.localDescription);
        console.log("[INFO] remotelocalDescription:");
        console.log(_this.pc.remoteDescription);
        return typeof callback === "function" ? callback() : void 0;
      };
      description = new this.RTCSessionDescription({
        type: type,
        sdp: sdp
      });
      return this.pc.setRemoteDescription(description, success, function() {
        return _this.trigger("error", "setRemoteDescription", description);
      });
    };

    RTC.prototype.receiveOffer = function(sdp, callback) {
      if (callback == null) {
        callback = null;
      }
      console.log("[INFO] Received offer");
      return this.receive(sdp, "offer", callback);
    };

    RTC.prototype.receiveAnswer = function(sdp) {
      console.log("[INFO] Received answer");
      return this.receive(sdp, "answer");
    };

    RTC.prototype.close = function() {
      try {
        return this.pc.close();
      } catch (e) {
        console.log("[ERROR] Error closing peerconnection");
        return console.log(e);
      } finally {
        this.pc = null;
        this.start();
      }
    };

    RTC.prototype.toggleMuteAudio = function() {
      var audioTracks;
      audioTracks = this.localstream.getAudioTracks();
      if (audioTracks.length === 0) {
        console.log("[MEDIA] No local audio available.");
        return;
      }
      if (this.isAudioActive) {
        return this.muteAudio();
      } else {
        return this.unmuteAudio();
      }
    };

    RTC.prototype.muteAudio = function() {
      var audioTrack, audioTracks, _i, _len;
      audioTracks = this.localstream.getAudioTracks();
      for (_i = 0, _len = audioTracks.length; _i < _len; _i++) {
        audioTrack = audioTracks[_i];
        audioTrack.enabled = false;
      }
      return this.isAudioActive = false;
    };

    RTC.prototype.unmuteAudio = function() {
      var audioTrack, audioTracks, _i, _len;
      audioTracks = this.localstream.getAudioTracks();
      for (_i = 0, _len = audioTracks.length; _i < _len; _i++) {
        audioTrack = audioTracks[_i];
        audioTrack.enabled = true;
      }
      return this.isAudioActive = true;
    };

    RTC.prototype.muteVideo = function() {
      var videoTrack, videoTracks, _i, _len;
      videoTracks = this.localstream.getVideoTracks();
      for (_i = 0, _len = videoTracks.length; _i < _len; _i++) {
        videoTrack = videoTracks[_i];
        videoTrack.enabled = false;
      }
      return this.isVideoActive = false;
    };

    RTC.prototype.unmuteVideo = function() {
      var videoTrack, videoTracks, _i, _len;
      videoTracks = this.localstream.getVideoTracks();
      for (_i = 0, _len = videoTracks.length; _i < _len; _i++) {
        videoTrack = videoTracks[_i];
        videoTrack.enabled = true;
      }
      return this.isVideoActive = true;
    };

    RTC.prototype.toggleMuteVideo = function() {
      var videoTracks;
      videoTracks = this.localstream.getVideoTracks();
      if (videoTracks.length === 0) {
        console.log("[MEDIA] No local audio available.");
        return;
      }
      if (this.isVideoActive) {
        return this.muteVideo();
      } else {
        return this.unmuteVideo();
      }
    };

    RTC.prototype.mediaState = function() {
      return {
        video: Boolean(this.isVideoActive),
        audio: Boolean(this.isAudioActive)
      };
    };

    RTC.prototype.insertDTMF = function(tone) {
      if (this.dtmfSender != null) {
        return this.dtmfSender.insertDTMF(tone, 500, 50);
      }
    };

    return RTC;

  })(Spine.Module);

  window.RTC = RTC;

  Parser = (function() {

    function Parser() {}

    Parser.getRegExprResult = function(pkt, re, indexes) {
      var index, key, line, result, _i, _len, _ref;
      result = {};
      _ref = _.keys(indexes);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        result[key] = void 0;
      }
      line = re.exec(pkt);
      if (line != null) {
        for (key in indexes) {
          index = indexes[key];
          if (index < line.length) {
            result[key] = line[index];
          }
        }
      }
      return result;
    };

    Parser.parse = function(pkt) {
      var message;
      console.log("[INFO] Parsing");
      console.log(pkt);
      message = {};
      _.extend(message, {
        frame: pkt
      });
      _.extend(message, this.parseFirstLine(pkt));
      _.extend(message, this.parseVias(pkt));
      _.extend(message, this.parseFrom(pkt));
      _.extend(message, this.parseTo(pkt));
      _.extend(message, this.parseRecordRoutes(pkt));
      _.extend(message, this.parseRoute(pkt));
      _.extend(message, this.parseContact(pkt));
      _.extend(message, this.parseCallId(pkt));
      _.extend(message, this.parseCSeq(pkt));
      _.extend(message, this.parseChallenge(pkt));
      _.extend(message, this.parseExpires(pkt));
      _.extend(message, this.parseContentType(pkt));
      _.extend(message, this.parseContent(pkt));
      console.log("[INFO] Parsed");
      console.log(message);
      return message;
    };

    Parser.parseFirstLine = function(pkt) {
      var code, firstLine, meth, methodRE, requestUri, responseRE, tmp;
      firstLine = pkt.split("\r\n")[0];
      responseRE = /^SIP\/2\.0 \d+/;
      if (responseRE.test(firstLine)) {
        tmp = firstLine.split(" ");
        tmp = _.rest(tmp);
        code = parseInt(tmp[0]);
        tmp = _.rest(tmp);
        meth = tmp.join(" ");
        return {
          responseCode: code,
          meth: meth,
          type: "response"
        };
      } else {
        methodRE = /(\w+)/;
        meth = methodRE.exec(firstLine)[0];
        requestUri = firstLine.split(" ")[1].split(";")[0];
        return {
          meth: meth,
          type: "request"
        };
      }
    };

    Parser.parseVias = function(pkt) {
      var branchRE, ret, tmp, viaRE, vias;
      viaRE = /Via\:\s+SIP\/2\.0\/[A-Z]+\s+([A-z0-9\.\:]+)/;
      tmp = _.filter(pkt.split("\r\n"), function(line) {
        return viaRE.test(line);
      });
      vias = _.map(tmp, function(via) {
        return via.replace(/;received=[A-z0-9\.\:]+/, "");
      });
      console.log(vias);
      if (vias.length > 0) {
        ret = this.getRegExprResult(vias[0], viaRE, {
          sentBy: 1
        });
        branchRE = /branch=([^;\s]+)/;
        ret = this.getRegExprResult(vias[0], branchRE, {
          branch: 1
        });
      }
      console.log(_.extend({
        vias: vias
      }, ret));
      return _.extend({
        vias: vias
      }, ret);
    };

    Parser.parseRecordRoutes = function(pkt) {
      var recordRouteRE, recordRoutes;
      recordRouteRE = /Record-Route\:/i;
      recordRoutes = _.filter(pkt.split("\r\n"), function(line) {
        return recordRouteRE.test(line);
      });
      return {
        recordRoutes: recordRoutes
      };
    };

    Parser.parseFrom = function(pkt) {
      var lineFromRE;
      lineFromRE = /(From|^f):\s*(\"[a-zA-Z0-9\-\.\!\%\*\+\`\'\~]*\"|[^<]*)\s*<?((sips?:((.+)@[a-zA-Z0-9\.\-]+(\:[0-9]+)?))([a-zA-Z0-9\-\.\!\%\*\+\`\'\~\;\=]*))>?(;tag=([a-zA-Z0-9\-\.\!\%\*\+\`\'\~]+))?(;.*)*/;
      return this.getRegExprResult(pkt, lineFromRE, {
        from: 5,
        ext: 6,
        fromTag: 10
      });
    };

    Parser.parseTo = function(pkt) {
      var lineToRE;
      lineToRE = /(To|^t):\s*(\"[a-zA-Z0-9\-\.\!\%\*\+\`\'\~]*\"|[^<]*)\s*<?((sips?:((.+)@[a-zA-Z0-9\.\-]+(\:[0-9]+)?))([a-zA-Z0-9\-\.\!\%\*\+\`\'\~\;\=]*))>?(;tag=([a-zA-Z0-9\-\.\!\%\*\+\`\'\~]+))?(;.*)*/;
      return this.getRegExprResult(pkt, lineToRE, {
        to: 5,
        ext2: 6,
        toTag: 10
      });
    };

    Parser.parseCallId = function(pkt) {
      var lineCallIdRE;
      lineCallIdRE = /Call-ID:\s(.+)/i;
      return this.getRegExprResult(pkt, lineCallIdRE, {
        callId: 1
      });
    };

    Parser.parseRoute = function(pkt) {
      var line, lineRoute, route, tmp, _i, _len, _ref;
      lineRoute = /Route\:/i;
      route = "";
      _ref = pkt.split('\r\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (lineRoute.test(line)) {
          tmp = line.split(': ');
          route += tmp[1] + "\r\nRoute: ";
        }
      }
      route = route.slice(0, -9);
      return {
        route: route
      };
    };

    Parser.parseContact = function(pkt) {
      var contactRE, gruuRE, result, result2;
      contactRE = /(Contact|^m):\s*(\"[a-zA-Z0-9\-\.\!\%\*\+\`\'\~]*\"|[^<]*)\s*<?((sips?:((.+)@[a-zA-Z0-9\.\-]+(\:[0-9]+)?))([a-zA-Z0-9\-\.\!\%\*\+\`\'\~\;\=]*))>?(.*)/;
      gruuRE = /pub\-gruu=\"(.+?)\"/;
      result = this.getRegExprResult(pkt, contactRE, {
        contact: 3
      });
      result2 = this.getRegExprResult(pkt, contactRE, {
        contact: 8
      });
      console.warn(result);
      console.warn(result2);
      return _.extend(result, this.getRegExprResult(pkt, gruuRE, {
        gruu: 1
      }));
    };

    Parser.parseCSeq = function(pkt) {
      var CSeqRE, cseq;
      CSeqRE = /CSeq\:\s(\d+)\s(.+)/gi;
      cseq = this.getRegExprResult(pkt, CSeqRE, {
        number: 1,
        meth: 2
      });
      cseq.number = parseInt(cseq.number);
      return {
        cseq: cseq
      };
    };

    Parser.parseChallenge = function(pkt) {
      var line, lineRe, nonce, nonceRe, opaque, opaqueRe, qop, qopRe, realm, realmRe, _ref, _ref1, _ref2, _ref3;
      lineRe = /^WWW-Authenticate\:.+$|^Proxy-Authenticate\:.+$/m;
      realmRe = /realm="([^\"^\\]+)"/;
      nonceRe = /nonce="([^\"^\\]+)"/;
      opaqueRe = /opaque="([^\"^\\]+)"/;
      qopRe = /qop=\"(auth|auth-int)\"/;
      line = lineRe.exec(pkt);
      if (line != null) {
        realm = (_ref = realmRe.exec(pkt)) != null ? _ref[1] : void 0;
        nonce = (_ref1 = nonceRe.exec(pkt)) != null ? _ref1[1] : void 0;
        opaque = (_ref2 = opaqueRe.exec(pkt)) != null ? _ref2[1] : void 0;
        qop = (_ref3 = qopRe.exec(pkt)) != null ? _ref3[1] : void 0;
      }
      return {
        realm: realm,
        nonce: nonce,
        opaque: opaque,
        qop: qop
      };
    };

    Parser.parseExpires = function(pkt) {
      var expiresRE;
      expiresRE = /expires=(\d{1,4})/;
      return this.getRegExprResult(pkt, expiresRE, {
        proposedExpires: 1
      });
    };

    Parser.parseContentType = function(pkt) {
      var contentTypeRE;
      contentTypeRE = /Content-Type: (.*)/i;
      return this.getRegExprResult(pkt, contentTypeRE, {
        contentType: 1
      });
    };

    Parser.parseContent = function(pkt) {
      return {
        content: (pkt.split("\r\n\r\n"))[1]
      };
    };

    return Parser;

  })();

  window.Parser = Parser;

  SipTransaction = (function() {

    function SipTransaction(args) {
      this.set = __bind(this.set, this);

      var _base, _base1, _base2, _base3, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.set(args);
      if ((_ref = this.domainName) == null) {
        this.domainName = "" + (this.randomString(12)) + ".invalid";
      }
      if ((_ref1 = this.IP) == null) {
        this.IP = this.randomIP();
      }
      if ((_ref2 = this.branch) == null) {
        this.branch = "z9hG4bK" + this.randomString(30);
      }
      if (!(this.cseq != null)) {
        this.cseq = {};
        if ((_ref3 = (_base = this.cseq).number) == null) {
          _base.number = _.random(0, 1000);
        }
        if ((_ref4 = (_base1 = this.cseq).meth) == null) {
          _base1.meth = this.meth;
        }
        if ((_ref5 = (_base2 = this.cseq).meth) == null) {
          _base2.meth = "";
        }
      }
      if ((_ref6 = this.fromTag) == null) {
        this.fromTag = this.randomString(20);
      }
      if ((_ref7 = this.toTag) == null) {
        this.toTag = this.randomString(20);
      }
      if ((_ref8 = this.callId) == null) {
        this.callId = this.randomString(16);
      }
      this.regid = 1;
      if ((_ref9 = (_base3 = SipTransaction.prototype).uuid) == null) {
        _base3.uuid = this.getUuid();
      }
      if ((_ref10 = this.tupleId) == null) {
        this.tupleId = this.randomString(8);
      }
      if ((_ref11 = this.cnonce) == null) {
        this.cnonce = "";
      }
      if ((_ref12 = this.nc) == null) {
        this.nc = 0;
      }
      if ((_ref13 = this.ncHex) == null) {
        this.ncHex = "00000000";
      }
    }

    SipTransaction.prototype.set = function(args) {
      var key, value, _results;
      _results = [];
      for (key in args) {
        value = args[key];
        _results.push(this[key] = value);
      }
      return _results;
    };

    SipTransaction.prototype.randomString = function(n, hex) {
      var array, character, limit, string, _i, _len;
      if (hex == null) {
        hex = false;
      }
      if (hex) {
        string = Math.random().toString(16).slice(2);
      } else {
        string = Math.random().toString(32).slice(2);
        string = string.concat(Math.random().toString(32).toUpperCase().slice(2));
      }
      array = _.shuffle(string.split(""));
      string = "";
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        character = array[_i];
        string += character;
      }
      limit = Math.min(string.length, n);
      string = string.slice(0, limit);
      while (string.length < n) {
        string += this.randomString(n - string.length, hex);
      }
      return string.slice(0, n);
    };

    SipTransaction.prototype.getUuid = function() {
      if (localStorage["uuid"] === null || localStorage["uuid"] === void 0) {
        localStorage["uuid"] = "" + (this.randomString(3, true)) + "-" + (this.randomString(4, true)) + "-" + (this.randomString(8, true));
      }
      this.uuid = localStorage["uuid"];
      this.getUuid = function() {
        return this.uuid;
      };
      return this.uuid;
    };

    SipTransaction.prototype.randomIP = function() {
      var array, i, _i;
      array = [];
      for (i = _i = 0; _i <= 3; i = ++_i) {
        array.push(_.random(1, 255));
      }
      return array.join('.');
    };

    SipTransaction.prototype.updateCnonceNcHex = function() {
      var hex;
      this.cnonce = this.randomString(8);
      this.nc += 1;
      hex = Number(this.nc).toString(16);
      this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
      if (this.nc === 4294967296) {
        this.nc = 1;
        return this.ncHex = "00000001";
      }
    };

    return SipTransaction;

  })();

  window.SipTransaction = SipTransaction;

  SipStack = (function(_super) {

    __extends(SipStack, _super);

    SipStack.prototype.addTransaction = function(transaction) {
      return this._transactions[transaction.branch] = transaction;
    };

    SipStack.prototype.getTransaction = function(message) {
      return this._transactions[message.branch];
    };

    SipStack.prototype.deleteTransaction = function(message) {
      return this._transactions = _.omit(this._transactions, message.branch);
    };

    SipStack.prototype.checkDialog = function(transaction) {
      var _this = this;
      return !_.isEmpty(_.find(this._transactions, function(tr) {
        var check;
        return check = tr.callId === transaction.callId;
      }));
    };

    SipStack.prototype.info = function(message, data) {
      console.log("[INFO]    " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.warning = function(message, data) {
      console.warn("[WARNING] " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.error = function(message, data) {
      console.error("[ERROR]   " + message);
      return this.trigger(message, data);
    };

    SipStack.prototype.states = ["OFFLINE", "REGISTERING (before challenge)", "REGISTERING (after challenge)", "REGISTERED", "INCOMING CALL", "CALLING", "RINGING", "CALL STABLISHED (caller)", "CALL STABLISHED (callee)", "HANGING", "CANCELLING"];

    SipStack.prototype.responsePhrases = {
      100: "Trying",
      180: "Ringing",
      200: "OK",
      202: "Accepted",
      400: "Bad Request",
      401: "Unauthorized",
      403: "Forbidden",
      404: "Not Found (User not found)",
      407: "Proxy Authentication Required",
      408: "Request Time Out",
      481: "Call/Transaction Does Not Exists",
      486: "Busy Here",
      488: "Not acceptable here",
      500: "Server Internal Error",
      503: "Service Unavaliable"
    };

    function SipStack() {
      this.setState = __bind(this.setState, this);

      this.sendInstantMessage = __bind(this.sendInstantMessage, this);

      this.sendWithSDP = __bind(this.sendWithSDP, this);

      this.send = __bind(this.send, this);

      this.hangup = __bind(this.hangup, this);

      this.answer = __bind(this.answer, this);

      this.call = __bind(this.call, this);

      this.register = __bind(this.register, this);

      this.createMessage = __bind(this.createMessage, this);

      this.getDigest = __bind(this.getDigest, this);

      this.error = __bind(this.error, this);

      this.warning = __bind(this.warning, this);

      this.info = __bind(this.info, this);

      this.checkDialog = __bind(this.checkDialog, this);

      this.deleteTransaction = __bind(this.deleteTransaction, this);

      this.getTransaction = __bind(this.getTransaction, this);

      this.addTransaction = __bind(this.addTransaction, this);

      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      SipStack.__super__.constructor.apply(this, arguments);
      if (this.mediaConstraints.audio + this.mediaConstraints.video > 0) {
        this.rtc = new RTC({
          mediaElements: this.mediaElements,
          mediaConstraints: this.mediaConstraints,
          turnServer: this.turnServer,
          stunServer: this.stunServer
        });
        if ((_ref = this.rtc) != null) {
          _ref.bind("localstream", function(localstream) {
            return _this.trigger("localstream", localstream);
          });
        }
        if ((_ref1 = this.rtc) != null) {
          _ref1.bind("remotestream", function(remotestream) {
            return _this.trigger("remotestream", remotestream);
          });
        }
      }
      this.sipServer = this.server.ip;
      this.port = this.server.port;
      this.path = this.server.path || "";
      this.transport = this.server.transport || "ws";
      this._transactions = {};
      this._instantMessages = {};
      this.setState(0);
      if ((_ref2 = this.hackViaTCP) == null) {
        this.hackViaTCP = false;
      }
      if ((_ref3 = this.hackIpContact) == null) {
        this.hackIpContact = false;
      }
      if ((_ref4 = this.hackno_Route_ACK_BYE) == null) {
        this.hackno_Route_ACK_BYE = false;
      }
      if ((_ref5 = this.hackContact_ACK_MESSAGES) == null) {
        this.hackContact_ACK_MESSAGES = false;
      }
      console.log("" + this.transport + "://" + this.sipServer + ":" + this.port + this.path);
      try {
        this.websocket = new WebSocket("" + this.transport + "://" + this.sipServer + ":" + this.port + this.path, "sip");
      } catch (e) {
        throw "" + this.transport + "://" + this.sipServer + ":" + this.port + this.path + " not open";
      }
      this.websocket.onerror = function(e) {
        console.error("Websocket failed.");
        return console.log(e.data);
      };
      this.info("websocket created");
      this.websocket.onopen = function(evt) {
        _this.info("websocket opened");
        return _this.onopen();
      };
      this.websocket.onmessage = function(evt) {
        var ack, busy, instantMessage, message, ok, register, ringing, transaction, _ref10, _ref11, _ref12, _ref13, _ref6, _ref7, _ref8, _ref9;
        message = Parser.parse(evt.data);
        _this.info("Input message", message);
        if ((_this.state > 2) && (message.cseq.meth === "REGISTER")) {
          if (!_this.getTransaction(message)) {
            return;
          }
          switch (message.responseCode) {
            case 200:
              _this.info("RE-REGISTER answer", message);
              return;
            case 401:
              register = _this.getTransaction(message);
              register.vias = message.vias;
              register.cseq.number += 1;
              _.extend(register, _.pick(message, "realm", "nonce", "toTag"));
              register.auth = true;
              _this.send(_this.createMessage(register));
              return;
          }
        }
        if (_this.state > 2 && message.cseq.meth === "MESSAGE") {
          switch (message.meth) {
            case "MESSAGE":
              console.log("[MESSAGE] " + message.content);
              instantMessage = {
                from: message.ext,
                to: message.ext2,
                content: message.content
              };
              _this.trigger("instant-message", instantMessage);
              _this.send(_this.createMessage(new SipTransaction(_.extend(message, {
                meth: "OK"
              }))));
              break;
            case "OK":
              console.log("[MESSAGE] OK");
              _this.deleteTransaction(message);
              break;
            default:
              if ((_ref6 = message.responseCode) !== 401 && _ref6 !== 407) {
                return;
              }
              if (!_this.getTransaction(message)) {
                return;
              }
              instantMessage = _this.getTransaction(message);
              _.extend(instantMessage, _.pick(message, "realm", "nonce", "toTag"));
              instantMessage.proxyAuth = message.responseCode === 407;
              instantMessage.auth = message.responseCode === 401;
              _this.send(_this.createMessage(instantMessage));
          }
          return;
        }
        if ((3 < (_ref7 = _this.state) && _ref7 < 9)) {
          if (message.meth === "INVITE") {
            _this.info("another-incoming-call", message);
            busy = _.clone(message);
            _.extend(busy, {
              meth: "Busy here"
            });
            _this.send(_this.createMessage(busy));
            return;
          }
        }
        switch (_this.state) {
          case 1:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            transaction.vias = message.vias;
            switch (message.responseCode) {
              case 200:
                _this.info("register-success", message);
                if ((_ref8 = _this.rtc) != null) {
                  _ref8.start();
                }
                _this.setState(3, message);
                transaction.expires = message.proposedExpires || 3600;
                _this.reRegister = function() {
                  var newRegister;
                  newRegister = _this.getTransaction(transaction);
                  newRegister.cseq.number += 1;
                  return _this.send(_this.createMessage(newRegister));
                };
                _this.t = setInterval(_this.reRegister, transaction.expires * 1000);
                _this.unregister = function() {
                  console.log("[INFO] unregistering");
                  transaction = _this.getTransaction(message);
                  transaction.expires = 0;
                  clearInterval(_this.t);
                  message = _this.createMessage(transaction);
                  _this.send(message);
                  return _this.setState(0, message);
                };
                return _this.gruu = message.gruu;
              case 401:
                _this.setState(2, message);
                transaction.cseq.number += 1;
                _.extend(transaction, _.pick(message, "realm", "nonce", "toTag", "qop", "opaque"));
                transaction.auth = true;
                if (transaction.qop === "auth") {
                  transaction.updateCnonceNcHex();
                }
                return _this.send(_this.createMessage(transaction));
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 2:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            transaction.vias = message.vias;
            switch (message.responseCode) {
              case 200:
                _this.info("register-success", message);
                if ((_ref9 = _this.rtc) != null) {
                  _ref9.start();
                }
                _this.setState(3, message);
                transaction.expires = message.proposedExpires;
                _this.reRegister = function() {
                  var newRegister;
                  newRegister = _this.getTransaction(transaction);
                  newRegister.cseq.number += 1;
                  return _this.send(_this.createMessage(newRegister));
                };
                _this.t = setInterval(_this.reRegister, transaction.expires * 1000);
                _this.unregister = function() {
                  console.log("[INFO] unregistering");
                  transaction = _this.getTransaction(message);
                  transaction.expires = 0;
                  clearInterval(_this.t);
                  message = _this.createMessage(transaction);
                  _this.send(message);
                  return _this.setState(0, message);
                };
                return _this.gruu = message.gruu;
              case 401:
                _this.info("register-fail", message);
                return _this.setState(0, message);
              default:
                _this.warning("message-unexpected", message);
                return _this.setState(0, message);
            }
            break;
          case 3:
            switch (message.meth) {
              case "INVITE":
                transaction = new SipTransaction(message);
                _this.addTransaction(transaction);
                ringing = _.clone(transaction);
                ringing.meth = "Ringing";
                _this.send(_this.createMessage(ringing));
                return _this.setState(6, message);
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 4:
            if (!_this.checkDialog(message)) {
              return;
            }
            switch (message.meth) {
              case "CANCEL":
                _this.info("Call ended");
                return _this.setState(3, message);
              case "ACK":
                return _this.setState(8, message);
              default:
                return _this.warning("Unexpected message", message);
            }
            break;
          case 5:
            if (!_this.getTransaction(message)) {
              return;
            }
            transaction = _this.getTransaction(message);
            switch (message.type) {
              case "response":
                if (_this.responsePhrases[message.responseCode]) {
                  _this.info(_this.responsePhrases[message.responseCode], message);
                } else {
                  _this.warning("Unexpected response", message);
                  return;
                }
                switch (message.responseCode) {
                  case 180:
                    return transaction.contact = message.contact;
                  case 200:
                    _this.info("Establishing call", message);
                    if ((_ref10 = _this.rtc) != null) {
                      _ref10.receiveAnswer(message.content);
                    }
                    _.extend(transaction, _.pick(message, "from", "to", "fromTag", "toTag"));
                    ack = new SipTransaction(message);
                    ack.meth = "ACK";
                    _this.send(_this.createMessage(ack));
                    return _this.setState(7, message);
                  case 401:
                  case 407:
                    if (message.responseCode === 401) {
                      _this.info("AUTH", message);
                    }
                    if (message.responseCode === 407) {
                      _this.info("PROXY-AUTH", message);
                    }
                    ack = new SipTransaction(_.omit(message, "nonce"));
                    ack.meth = "ACK";
                    ack.vias = message.vias;
                    _this.send(_this.createMessage(ack));
                    transaction.vias = message.vias;
                    transaction.cseq.number += 1;
                    _.extend(transaction, _.pick(message, "realm", "nonce", "toTag"));
                    transaction.auth = message.responseCode === 401;
                    transaction.proxyAuth = message.responseCode === 407;
                    console.log(transaction);
                    message = _this.createMessage(transaction);
                    return _this.sendWithSDP(message, "offer", null);
                  default:
                    if (400 <= message.responseCode) {
                      ack = new SipTransaction(_.omit(message, "nonce"));
                      ack.meth = "ACK";
                      ack.vias = message.vias;
                      _this.send(_this.createMessage(ack));
                      _this.setState(3);
                      return _this.deleteTransaction("INVITE");
                    }
                }
                break;
              case "request":
                switch (message.meth) {
                  case "BYE":
                    _this.info("Call ended", message);
                    ok = new SipTransaction(message);
                    ok.meth = "OK";
                    _this.send(_this.createMessage(ok));
                    return _this.setState(3, message);
                  default:
                    return _this.warning("Unexpected message", message);
                }
            }
            break;
          case 6:
            if (!_this.checkDialog(message)) {
              return;
            }
            _this.info("RINGING", message);
            switch (message.meth) {
              case "CANCEL":
                _this.info("Call ended", message);
                ok = new SipTransaction(message);
                ok.meth = "OK";
                _this.send(_this.createMessage(ok));
                return _this.setState(3, message);
            }
            break;
          case 7:
          case 8:
            if (!_this.checkDialog(message)) {
              return;
            }
            _this.info("CALL ESTABLISHED", message);
            switch (message.meth) {
              case "BYE":
                _this.info("Call finished", message);
                transaction = new SipTransaction(message);
                transaction.vias = message.vias;
                transaction.meth = "OK";
                ok = _.clone(transaction);
                _this.send(_this.createMessage(ok));
                if ((_ref11 = _this.rtc) != null) {
                  _ref11.close();
                }
                return _this.setState(3, message);
            }
            break;
          case 9:
            if (!_this.getTransaction(message)) {
              return;
            }
            _this.info("HANGING UP", message);
            _this.info("Call ended", message);
            if ((_ref12 = _this.rtc) != null) {
              _ref12.close();
            }
            return _this.setState(3, message);
          case 10:
            if (!_this.getTransaction(message)) {
              return;
            }
            _this.info("HANGING UP", message);
            _this.info("Call ended", message);
            if ((_ref13 = _this.rtc) != null) {
              _ref13.close();
            }
            return _this.setState(3, message);
        }
      };
      this.websocket.onclose = function(evt) {
        return _this.info("websocket closed");
      };
    }

    SipStack.prototype.getDigest = function(transaction) {
      var authExtension, ha1, ha2, sol;
      authExtension = transaction.ext;
      if (transaction.qop === "auth") {
        ha1 = CryptoJS.MD5("" + transaction.privId + ":" + transaction.realm + ":" + transaction.pass);
        console.log("HA1 = md5(" + transaction.privId + ":" + transaction.realm + ":" + transaction.pass + ")");
      } else {
        ha1 = CryptoJS.MD5("" + transaction.ext + ":" + transaction.realm + ":" + transaction.pass);
        console.log("HA1 = md5(" + transaction.ext + ":" + transaction.realm + ":" + transaction.pass + ")");
      }
      console.log("HA1 = " + ha1);
      ha2 = CryptoJS.MD5("" + transaction.meth + ":" + transaction.requestUri);
      console.log("HA2 = md5(" + transaction.meth + ":" + transaction.requestUri + ")");
      console.log("HA2 = " + ha2);
      if (transaction.qop === "auth") {
        sol = CryptoJS.MD5("" + ha1 + ":" + transaction.nonce + ":" + transaction.ncHex + ":" + transaction.cnonce + ":auth:" + ha2);
        console.log("response = md5(" + ha1 + ":" + transaction.nonce + ":" + transaction.ncHex + ":" + transaction.cnonce + ":auth:" + ha2 + ")");
      } else {
        sol = CryptoJS.MD5("" + ha1 + ":" + transaction.nonce + ":" + ha2);
        console.log("response = md5(" + ha1 + ":" + transaction.nonce + ":" + ha2 + ")");
      }
      console.log("response = " + sol);
      return sol;
    };

    SipStack.prototype.createMessage = function(transaction) {
      var address, authExt, authUri, data, length, opaque, qop, rr, specialCharsLength, specialCharsRE, _i, _len, _ref, _ref1;
      transaction = new SipTransaction(transaction);
      transaction.uri = "sip:" + transaction.ext + "@" + (this.domain || this.sipServer);
      transaction.uri2 = "sip:" + transaction.ext2 + "@" + (transaction.domain2 || this.sipServer);
      transaction.targetUri = "sip:" + this.sipServer;
      if (transaction.meth === "BYE") {
        transaction.cseq.number += 1;
      }
      switch (transaction.meth) {
        case "REGISTER":
          transaction.requestUri = transaction.targetUri;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "INVITE":
        case "MESSAGE":
        case "CANCEL":
          transaction.requestUri = transaction.uri2;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "ACK":
        case "BYE":
          transaction.requestUri = transaction.contact || transaction.uri2;
          data = "" + transaction.meth + " " + transaction.requestUri + " SIP/2.0\r\n";
          break;
        case "OK":
          data = "SIP/2.0 200 OK\r\n";
          break;
        case "Ringing":
          data = "SIP/2.0 180 Ringing\r\n";
          break;
        case "Busy here":
          data = "SIP/2.0 486 Busy Here\r\n";
      }
      if ((transaction.cseq.meth === "INVITE" && transaction.meth !== "ACK") && (_.isArray(transaction.recordRoutes))) {
        _ref = transaction.recordRoutes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rr = _ref[_i];
          data += rr + "\r\n";
        }
      } else {
        switch (transaction.meth) {
          case "REGISTER":
          case "INVITE":
          case "MESSAGE":
          case "CANCEL":
            data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr>\r\n";
            break;
          case "OK":
            if (transaction.cseq.meth !== "MESSAGE") {
              data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr=on>\r\n";
            }
            break;
          case "BYE":
          case "ACK":
            if (!this.hackno_Route_ACK_BYE) {
              if (transaction.cseq.meth !== "MESSAGE") {
                data += "Route: <sip:" + this.sipServer + ":" + this.port + ";transport=ws;lr=on>\r\n";
              }
            }
        }
      }
      if (_.isArray(transaction.vias)) {
        data += (transaction.vias.join("\r\n")) + "\r\n";
      } else {
        data += "Via: SIP/2.0/" + ((this.hackViaTCP && "TCP") || this.transport.toUpperCase()) + " " + transaction.domainName + ";branch=" + transaction.branch + "\r\n";
      }
      data += "From: <" + transaction.uri + ";tag=" + transaction.fromTag + ">\r\n";
      switch (transaction.meth) {
        case "REGISTER":
          data += "To: <" + transaction.uri + ">\r\n";
          break;
        case "INVITE":
        case "MESSAGE":
        case "CANCEL":
          data += "To:  <" + transaction.uri2 + ">\r\n";
          break;
        default:
          data += "To: <" + transaction.uri2 + ">;tag=" + transaction.toTag + "\r\n";
      }
      data += "Call-ID: " + transaction.callId + "\r\n";
      switch (transaction.meth) {
        case "OK":
          data += "CSeq: " + transaction.cseq.number + " " + (transaction.cseq.meth || transaction.meth) + "\r\n";
          break;
        case "Ringing":
          data += "CSeq: " + transaction.cseq.number + " " + transaction.cseq.meth + "\r\n";
          break;
        case "ACK":
          data += "CSeq: " + transaction.cseq.number + " ACK\r\n";
          break;
        case "Busy here":
          data += "CSeq: " + transaction.cseq.number + " INVITE\r\n";
          break;
        default:
          data += "CSeq: " + transaction.cseq.number + " " + transaction.meth + "\r\n";
      }
      data += "Max-Forwards: 70\r\n";
      if (transaction.meth === "REGISTER" || transaction.meth === "INVITE") {
        data += "Allow: INVITE, ACK, CANCEL, BYE, MESSAGE\r\n";
      }
      data += "Supported: path, gruu\r\n";
      data += "User-Agent: QoffeeSIP 0.7\r\n";
      address = (this.hackIpContact && transaction.IP) || transaction.domainName;
      switch (transaction.meth) {
        case "Ringing":
          if (this.gruu) {
            data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";gr=urn:uuid:" + transaction.uuid + ">\r\n";
          } else {
            data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";transport=ws>\r\n";
          }
          break;
        case "OK":
          if (transaction.cseq.meth === "INVITE") {
            if (this.gruu) {
              data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";gr=urn:uuid:" + transaction.uuid + ">\r\n";
            } else {
              data += "Contact: <sip:" + transaction.ext2 + "@" + address + ";transport=ws>\r\n";
            }
          }
          break;
        case "REGISTER":
          data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws>";
          break;
        case "INVITE":
          if (this.gruu) {
            data += "Contact: <" + this.gruu + ";ob>\r\n";
          } else {
            data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws;ob>\r\n";
          }
          break;
        case "ACK":
        case "MESSAGE":
          if (this.hackContact_ACK_MESSAGES) {
            if (this.gruu) {
              data += "Contact: <" + this.gruu + ";ob>\r\n";
            } else {
              data += "Contact: <sip:" + transaction.ext + "@" + address + ";transport=ws;ob>\r\n";
            }
          }
      }
      switch (transaction.meth) {
        case "REGISTER":
          data += ";reg-id=" + transaction.regid;
          data += ";+sip.instance=\"<urn:uuid:" + transaction.uuid + ">\"";
          if (transaction.expires != null) {
            data += ";expires=" + transaction.expires;
          }
          data += "\r\n";
      }
      if (transaction.nonce != null) {
        opaque = "";
        if (transaction.opaque != null) {
          opaque = ",opaque=\"" + transaction.opaque + "\"";
        }
        qop = "";
        if (transaction.qop != null) {
          qop = ",qop=" + transaction.qop + ",cnonce=\"" + transaction.cnonce + "\",nc=" + transaction.ncHex;
        }
        if (transaction.auth === true) {
          if (transaction.cseq.meth === "REGISTER") {
            authUri = transaction.targetUri;
          } else {
            authUri = transaction.uri2;
          }
          data += "Authorization:";
        }
        if (transaction.proxyAuth === true) {
          authUri = transaction.uri2;
          data += "Proxy-Authorization:";
        }
        transaction.response = this.getDigest(transaction);
        authExt = transaction.ext;
        if (transaction.privId) {
          authExt = transaction.privId;
        }
        data += " Digest username=\"" + authExt + "\",realm=\"" + transaction.realm + "\",";
        data += "nonce=\"" + transaction.nonce + "\"" + opaque + ",uri=\"" + authUri + "\",response=\"" + transaction.response + "\",algorithm=MD5" + qop + "\r\n";
      }
      switch (transaction.meth) {
        case "INVITE":
        case "OK":
          if (transaction.cseq.meth === "INVITE") {
            data += "Content-Type: application/sdp\r\n";
          } else {
            data += "Content-Length: 0\r\n\r\n";
          }
          break;
        case "MESSAGE":
          specialCharsRE = /[ñçáéíóúàèìòùâêîôûäëïöü]/gi;
          specialCharsLength = (_ref1 = transaction.content.match(specialCharsRE)) != null ? _ref1.length : void 0;
          length = transaction.content.length + (specialCharsLength || 0);
          data += "Content-Length: " + (length || 0) + "\r\n";
          data += "Content-Type: text/plain;charset=utf-8\r\n\r\n";
          data += transaction.content;
          break;
        default:
          data += "Content-Length: 0\r\n\r\n";
      }
      return data;
    };

    SipStack.prototype.register = function(ext, pass, domain, privateId) {
      var message, transaction;
      this.ext = ext;
      this.pass = pass;
      this.domain = domain;
      this.privateId = privateId;
      this.domain || (this.domain = this.sipServer);
      transaction = new SipTransaction({
        meth: "REGISTER",
        ext: this.ext,
        domain: this.domain,
        pass: this.pass || "",
        privId: this.privateId || ""
      });
      this.addTransaction(transaction);
      this.setState(1, transaction);
      message = this.createMessage(transaction);
      return this.send(message);
    };

    SipStack.prototype.call = function(ext2, domain2) {
      var message, transaction;
      transaction = new SipTransaction({
        meth: "INVITE",
        ext: this.ext,
        pass: this.pass,
        ext2: ext2,
        domain2: domain2 || this.domain
      });
      this.addTransaction(transaction);
      this.setState(5, transaction);
      message = this.createMessage(transaction);
      return this.sendWithSDP(message, "offer", null);
    };

    SipStack.prototype.answer = function(branch) {
      var ok;
      ok = _.clone(this.getTransaction({
        branch: branch
      }));
      ok.meth = "OK";
      this.sendWithSDP(this.createMessage(ok), "answer", this.getTransaction({
        branch: branch
      }).content);
      return this.setState(4, ok);
    };

    SipStack.prototype.hangup = function(branch) {
      var busy, bye, cancel, invite, swap, _ref, _ref1, _ref2;
      if ((_ref = this.rtc) != null) {
        _ref.unbind("sdp");
      }
      swap = function(d, p1, p2) {
        var _ref1;
        return _ref1 = [d[p2], d[p1]], d[p1] = _ref1[0], d[p2] = _ref1[1], _ref1;
      };
      invite = this.getTransaction({
        branch: branch
      });
      switch (this.state) {
        case 5:
          cancel = new SipTransaction({
            meth: "CANCEL",
            ext: this.ext,
            domain: this.domain,
            ext2: invite.ext2,
            domain2: invite.domain2
          });
          _.extend(cancel, _.pick(invite, "callId", "fromTag", "from", "to", "cseq", "domainName", "branch"));
          this.send(this.createMessage(cancel));
          return this.setState(10);
        case 6:
          busy = new SipTransaction({
            meth: "Busy here",
            ext: this.ext,
            ext2: invite.ext
          });
          _.extend(busy, _.pick(invite, "callId", "fromTag", "from", "to", "cseq", "domainName", "branch", "vias"));
          this.send(this.createMessage(busy));
          return this.setState(9, busy);
        case 7:
          bye = new SipTransaction({
            meth: "BYE",
            ext: this.ext,
            ext2: invite.ext2
          });
          _.extend(bye, _.pick(invite, "callId", "contact", "fromTag", "toTag", "from", "to", "cseq"));
          this.send(this.createMessage(bye));
          this.addTransaction(bye);
          this.setState(9, bye);
          return (_ref1 = this.rtc) != null ? _ref1.close() : void 0;
        case 8:
          bye = new SipTransaction({
            meth: "BYE",
            ext: this.ext,
            ext2: invite.ext
          });
          _.extend(bye, _.pick(invite, "callId", "contact", "fromTag", "toTag", "from", "to", "cseq", "vias"));
          swap(bye, "fromTag", "toTag");
          swap(bye, "from", "to");
          this.send(this.createMessage(bye));
          this.addTransaction(bye);
          this.setState(9, bye);
          return (_ref2 = this.rtc) != null ? _ref2.close() : void 0;
      }
    };

    SipStack.prototype.send = function(data) {
      if (data != null) {
        console.log("[INFO] Sending data", data);
        try {
          return this.websocket.send(data);
        } catch (e) {
          return this.error("websocket", e);
        }
      } else {
        return console.log("[INFO] Not sending data");
      }
    };

    SipStack.prototype.sendWithSDP = function(data, type, sdp) {
      var _ref, _ref1, _ref2, _ref3,
        _this = this;
      if ((_ref = this.rtc) != null) {
        _ref.start();
      }
      if ((_ref1 = this.rtc) != null) {
        _ref1.bind("sdp", function(sdp) {
          var _ref2;
          data += "Content-Length: " + sdp.length + "\r\n\r\n";
          data += sdp;
          _this.send(data);
          return (_ref2 = _this.rtc) != null ? _ref2.unbind("sdp") : void 0;
        });
      }
      if (type === "offer") {
        if ((_ref2 = this.rtc) != null) {
          _ref2.createOffer();
        }
      }
      if (type === "answer") {
        return (_ref3 = this.rtc) != null ? _ref3.receiveOffer(sdp, function() {
          var _ref4;
          return (_ref4 = _this.rtc) != null ? _ref4.createAnswer() : void 0;
        }) : void 0;
      }
    };

    SipStack.prototype.sendInstantMessage = function(ext2, domain2, text) {
      var message;
      message = new SipTransaction({
        meth: "MESSAGE",
        ext: this.ext,
        pass: this.pass,
        ext2: ext2,
        domain2: domain2,
        content: text
      });
      this.addTransaction(message);
      return this.send(this.createMessage(message));
    };

    SipStack.prototype.setState = function(state, data) {
      this.state = state;
      console.log("[INFO] New state  " + this.states[this.state] + ("(" + this.state + ")"));
      return this.trigger("new-state", this.state, data);
    };

    return SipStack;

  })(Spine.Controller);

  window.SipStack = SipStack;

  QS = (function(_super) {

    __extends(QS, _super);

    function QS(options) {
      this.insertDTMF = __bind(this.insertDTMF, this);

      this.attachStream = __bind(this.attachStream, this);

      this.mediaState = __bind(this.mediaState, this);

      this.unmuteAudio = __bind(this.unmuteAudio, this);

      this.muteAudio = __bind(this.muteAudio, this);

      this.unmuteVideo = __bind(this.unmuteVideo, this);

      this.muteVideo = __bind(this.muteVideo, this);

      this.toggleMuteAudio = __bind(this.toggleMuteAudio, this);

      this.toggleMuteVideo = __bind(this.toggleMuteVideo, this);

      this.off = __bind(this.off, this);

      this.on = __bind(this.on, this);

      this.cbRegisterSuccess = __bind(this.cbRegisterSuccess, this);

      this.cbRegisterFail = __bind(this.cbRegisterFail, this);

      this.cbAnotherIncomingCall = __bind(this.cbAnotherIncomingCall, this);

      this.cbRemotestream = __bind(this.cbRemotestream, this);

      this.cbLocalstream = __bind(this.cbLocalstream, this);

      this.chat = __bind(this.chat, this);

      this.updateMediaState = __bind(this.updateMediaState, this);

      this.updatePresenceState = __bind(this.updatePresenceState, this);

      this.unregister = __bind(this.unregister, this);

      this.hangup = __bind(this.hangup, this);

      this.answer = __bind(this.answer, this);

      this.call = __bind(this.call, this);

      this.capabilities = __bind(this.capabilities, this);

      this.register = __bind(this.register, this);

      this.cbStateChange = __bind(this.cbStateChange, this);

      this.cbInstantMessage = __bind(this.cbInstantMessage, this);
      QS.__super__.constructor.apply(this, arguments);
      this.lastState = "";
      this.stateflow = [];
      this.mappedEvents = ['qs-instant-message', 'qs-localstream', 'qs-remotestream', 'qs-register-fail', 'qs-register-success', 'qs-another-incoming-call'];
      this.customEvents = {
        'qs-ringing': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-calling': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-end-call': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-lost-call': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-established': {
          stack: 'new-state',
          cb: this.cbStateChange
        },
        'qs-instant-message': {
          stack: 'instant-message',
          cb: this.cbInstantMessage
        },
        'qs-presence-update': {
          stack: 'instant-message',
          cb: this.cbInstantMessage
        },
        'qs-mediastate-update': {
          stack: 'instant-message',
          cb: this.cbInstantMessage
        }
      };
      this.customEventsReverse = {
        'new-state': {
          counter: 0
        },
        'instant-message': {
          counter: 0
        }
      };
      this.libEvents = {
        'qs-localstream': {
          stack: 'localstream',
          cb: this.cbLocalstream
        },
        'qs-remotestream': {
          stack: 'remotestream',
          cb: this.cbRemotestream
        },
        'qs-register-fail': {
          stack: 'register-fail',
          cb: this.cbRegisterFail
        },
        'qs-register-success': {
          stack: 'register-success',
          cb: this.cbRegisterSuccess
        },
        'qs-another-incoming-call': {
          stack: "another-incoming-call",
          cb: this.cbAnotherIncomingCall
        }
      };
      this.sipStack = new SipStack({
        server: this.server,
        stunServer: this.stunServer,
        turnServer: this.turnServer,
        hackViaTCP: this.hackViaTCP,
        hackIpContact: this.hackIpContact,
        hackno_Route_ACK_BYE: this.hackno_Route_ACK_BYE,
        hackContact_ACK_MESSAGES: this.hackContact_ACK_MESSAGES,
        mediaConstraints: this.mediaConstraints,
        mediaElements: this.mediaElements,
        onopen: this.onopen || function() {
          return false;
        }
      });
    }

    QS.prototype.cbInstantMessage = function(data) {
      var chattext, header, lines;
      lines = data.content.split(/\n/);
      header = JSON.parse(lines[0]);
      chattext = lines[1];
      if (header.hasOwnProperty("presenceState")) {
        this.trigger('qs-presence-update', data.from, header.presenceState, header.answerme);
      }
      if (header.hasOwnProperty("mediaState")) {
        this.trigger('qs-mediastate-update', header.mediaState.video);
      }
      if (chattext.length) {
        return this.trigger('qs-instant-message', data.from, chattext);
      }
    };

    QS.prototype.cbStateChange = function(state, message) {
      this.state = state;
      console.warn(this.stateflow);
      switch (this.state) {
        case 3:
          if (_.isEqual(this.stateflow, [5, 78, 9])) {
            console.warn("outgoing call, answered, caller hangs up");
            this.trigger('qs-end-call', message);
          } else if (_.isEqual(this.stateflow, [5, 78])) {
            console.warn("outgoing call, answered, callee hangs up");
            this.trigger('qs-end-call', message);
          } else if (_.isEqual(this.stateflow, [6, 78])) {
            console.warn("incoming call, answered, caller hangs up");
            this.trigger('qs-end-call', message);
          } else if (_.isEqual(this.stateflow, [6, 78, 9])) {
            console.warn("incoming call, answered, callee hangs up");
            this.trigger('qs-end-call', message);
          } else if (_.isEqual(this.stateflow, [5, 10])) {
            console.warn("outgoing call, not answered, hangup by caller or callee");
            this.trigger('qs-lost-call', message);
          } else if (_.isEqual(this.stateflow, [5])) {
            console.warn("outgoing call, not answered, hangup by callee");
            this.trigger('qs-lost-call', message);
          } else if (_.isEqual(this.stateflow, [6])) {
            console.warn("incoming call, not answered, hang it up by caller");
            this.trigger('qs-lost-call', message);
          } else if (_.isEqual(this.stateflow, [6, 9])) {
            console.warn("incoming call, not answered, hang it up by callee");
            this.trigger('qs-lost-call', message);
          }
          return this.stateflow = [];
        case 5:
          this.stateflow.push(5);
          return this.trigger('qs-calling', message);
        case 6:
          this.stateflow.push(6);
          return this.trigger('qs-ringing', message);
        case 7:
        case 8:
          this.stateflow.push(78);
          return this.trigger('qs-established', message);
        case 9:
          return this.stateflow.push(9);
        case 10:
          return this.stateflow.push(10);
      }
    };

    QS.prototype.register = function(ext, pass, domain, userAuthName) {
      return this.sipStack.register(ext, pass, domain, userAuthName);
    };

    QS.prototype.capabilities = function() {
      return ['audio', 'video', 'chat', 'presence'];
    };

    QS.prototype.call = function(ext, domain) {
      return this.sipStack.call(ext, domain);
    };

    QS.prototype.answer = function(callid) {
      return this.sipStack.answer(callid);
    };

    QS.prototype.hangup = function(callid) {
      return this.sipStack.hangup(callid);
    };

    QS.prototype.unregister = function() {
      return this.sipStack.unregister();
    };

    QS.prototype.updatePresenceState = function(ext, domain, state, answerme) {
      var content;
      if (answerme == null) {
        answerme = false;
      }
      this.lastState = state;
      content = JSON.stringify({
        presenceState: state,
        answerme: Boolean(answerme)
      }) + "\n";
      return this.sipStack.sendInstantMessage(ext, domain, content);
    };

    QS.prototype.updateMediaState = function(ext, domain) {
      var content;
      content = JSON.stringify({
        presenceState: this.sipStack.rtc.mediaState()
      }) + "\n";
      return this.sipStack.sendInstantMessage(ext, domain, content);
    };

    QS.prototype.chat = function(ext, domain, text) {
      var content;
      content = JSON.stringify({
        presenceState: this.lastState
      }) + "\n" + text;
      return this.sipStack.sendInstantMessage(ext, domain, content);
    };

    QS.prototype.cbLocalstream = function(localstream) {
      return this.trigger("qs-localstream", localstream);
    };

    QS.prototype.cbRemotestream = function(remotestream) {
      return this.trigger("qs-remotestream", remotestream);
    };

    QS.prototype.cbAnotherIncomingCall = function(data) {
      return this.trigger("qs-another-incoming-call", data);
    };

    QS.prototype.cbRegisterFail = function() {
      return this.trigger('qs-register-fail');
    };

    QS.prototype.cbRegisterSuccess = function() {
      return this.trigger('qs-register-success');
    };

    QS.prototype.on = function(eventName, callback) {
      var _ref;
      if (this.customEvents[eventName] != null) {
        if (this.customEventsReverse[this.customEvents[eventName].stack].counter === 0) {
          this.customEventsReverse[this.customEvents[eventName].stack].counter += 1;
          this.sipStack.bind(this.customEvents[eventName].stack, this.customEvents[eventName].cb);
        }
      } else {
        if (_ref = !eventName, __indexOf.call(this.mappedEvents, _ref) >= 0) {
          return;
        }
        this.sipStack.bind(this.libEvents[eventName].stack, this.libEvents[eventName].cb);
      }
      return this.bind(eventName, callback);
    };

    QS.prototype.off = function(eventName, callback) {
      var _ref;
      if (this.customEvents[eventName] != null) {
        if (this.customEventsReverse[this.customEvents[eventName].stack].counter !== 0) {
          this.customEventsReverse[this.customEvents[eventName].stack].counter -= 1;
          this.sipStack.unbind(this.customEvents[eventName].stack, this.customEvents[eventName].cb);
        }
      } else {
        if (_ref = !eventName, __indexOf.call(this.mappedEvents, _ref) >= 0) {
          return;
        }
        this.sipStack.unbind(this.libEvents[eventName].stack, this.libEvents[eventName].cb);
      }
      return this.unbind(eventName, callback);
    };

    QS.prototype.toggleMuteVideo = function() {
      return this.sipStack.rtc.toggleMuteVideo();
    };

    QS.prototype.toggleMuteAudio = function() {
      return this.sipStack.rtc.toggleMuteAudio();
    };

    QS.prototype.muteVideo = function() {
      return this.sipStack.rtc.muteVideo();
    };

    QS.prototype.unmuteVideo = function() {
      return this.sipStack.rtc.unmuteVideo();
    };

    QS.prototype.muteAudio = function() {
      return this.sipStack.rtc.muteAudio();
    };

    QS.prototype.unmuteAudio = function() {
      return this.sipStack.rtc.unmuteAudio();
    };

    QS.prototype.mediaState = function() {
      return this.sipStack.rtc.mediaState();
    };

    QS.prototype.attachStream = function($d, stream) {
      return this.sipStack.rtc.attachStream($d, stream);
    };

    QS.prototype.insertDTMF = function(tone) {
      return this.sipStack.rtc.insertDTMF(tone);
    };

    return QS;

  })(Spine.Controller);

  window.QS = QS;

}).call(this);
